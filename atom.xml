<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>听香水榭</title>
  <icon>https://www.gravatar.com/avatar/fde8f1ea85d935c71320eeb1761fd455</icon>
  <subtitle>听香水榭，取自金庸《天龙八部》，是为姑苏慕容府上阿朱姑娘的住所。巧的是，古龙笔下的楚留香住的地方叫做“香榭”。在我心中，听香水榭是世外桃源的另一种说法。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tingxiangshuixie.com/"/>
  <updated>2018-03-11T09:52:53.195Z</updated>
  <id>http://www.tingxiangshuixie.com/</id>
  
  <author>
    <name>文末</name>
    <email>547137393@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>带你彻底理解Java中的final关键字</title>
    <link href="http://www.tingxiangshuixie.com/2018/03/11/java_final/"/>
    <id>http://www.tingxiangshuixie.com/2018/03/11/java_final/</id>
    <published>2018-03-11T14:54:00.000Z</published>
    <updated>2018-03-11T09:52:53.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说来惭愧，我已经很久没有更新博客了。原因大概有二：其一是 <strong>主观上</strong> 笔者近来有些浮躁，难以静下心了进行总结与反思；其二则是 <strong>客观上</strong> 近几个月从公司的项目到个人的项目都非常的琐碎繁杂，已经完全透支了笔者的写作热情。</p></blockquote><blockquote><p>好在最近的历练的确使我有了方方面面的提升，以后会尽可能多地把技术分享带给大家。话不多说，本篇讨论的只有 <strong>Java</strong> 中的一个关键字——<strong>final</strong>。</p></blockquote><a id="more"></a><p>final，顾名思义，是为 <strong>最终的</strong>、<strong>无法改变的</strong>。final可能被使用的情况有三种：<strong>数据</strong>、<strong>方法</strong> 和 <strong>类</strong>，下面笔者将分别说明这三种情况的差异。</p><h3 id="final修饰数据"><a href="#final修饰数据" class="headerlink" title="final修饰数据"></a>final修饰数据</h3><p>数据分为两种类型：基本类型（boolean、byte、char、short、int、long、float、double）和对象。<strong>当final用于修饰基本类型时，代表其数值自初始化赋值后恒定不变。当final用于修饰对象引用时，代表其引用无法被改变。</strong> 即当x引用为一个Object时（final Object x = new Object();），不能再将x改为指向另一个对象。</p><p>值得注意的是，当final修饰对象引用时，虽然无法将引用“重定向”，但仍可以<strong>修改当前引用对象的成员变量</strong>，如使用set()方法等。另外，在Java中 <strong>数组也是对象</strong>，当final用于修饰数组引用时，数组内部元素仍可以被改变。</p><h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><p>当final被用于修饰一个方法时，代表该方法是无法被 <strong>重写</strong>（override）的。任何被private修饰的方法，都隐式地指定为final。</p><p>我们都知道可以直接使用子类对象来代替父类对象作为参数传递，而不用担心发生类型转换的问题，这被称为 <strong>向上转型</strong>。实际上，在程序运行时，计算机会根据参数的类型选择相应的方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Father object)</span></span>&#123;</span><br><span class="line">object.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当程序员向test方法中传入Son对象时，计算机不会运行Father类中的doSomething()方法，而是 <strong>运行Son类中的doSomething()方法</strong>。因此，当运行一个被final修饰的方法时，计算机不需要判断当前对象的类型，这会带来微小的性能提升。但是，开发者往往无法预计当前编写的类在之后的漫长时间中会起到何种作用，所以不要单纯为了微小的性能提升而使用final修饰方法，除非开发者 <strong>明确禁止此方法被覆盖</strong>。</p><p>final修饰方法还有另外一个情况——用于修饰方法参数，这在 <strong>匿名内部类</strong> 中较为常见。这代表开发者无法在方法中修改此参数引用指向的对象。Java中每个类文件被编译成单独的class文件，内部类和外部类处于同样的等级。如果内部类方法中可以使用并修改外部类变量，则 <strong>内部类必须始终持有外部类的引用</strong>，这将可能导致外部类无法被回收掉。而Java这种规则，实际上是将参数拷贝一份拿来使用，不会影响外部类的垃圾回收工作。</p><h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><p>当某个类被定义为final时，代表该类不可被继承。由于类不可被继承，自然类中的任何方法都不可被重写（override）。也就是说，final类中的所有方法都被隐式地指定为final。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;说来惭愧，我已经很久没有更新博客了。原因大概有二：其一是 &lt;strong&gt;主观上&lt;/strong&gt; 笔者近来有些浮躁，难以静下心了进行总结与反思；其二则是 &lt;strong&gt;客观上&lt;/strong&gt; 近几个月从公司的项目到个人的项目都非常的琐碎繁杂，已经完全透支了笔者的写作热情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;好在最近的历练的确使我有了方方面面的提升，以后会尽可能多地把技术分享带给大家。话不多说，本篇讨论的只有 &lt;strong&gt;Java&lt;/strong&gt; 中的一个关键字——&lt;strong&gt;final&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>《50 Android Hacks》读书笔记41-50</title>
    <link href="http://www.tingxiangshuixie.com/2017/10/10/50_android_hacks_5/"/>
    <id>http://www.tingxiangshuixie.com/2017/10/10/50_android_hacks_5/</id>
    <published>2017-10-10T10:15:00.000Z</published>
    <updated>2017-10-11T15:21:22.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hack41-使用ORMLite构建数据库"><a href="#Hack41-使用ORMLite构建数据库" class="headerlink" title="Hack41 使用ORMLite构建数据库"></a>Hack41 使用ORMLite构建数据库</h3><p><em>问题：Android ORMLite框架如何使用？</em></p><p>解决方案：<strong>ORMLite</strong> 是一种对象关系映射工具，可用于读写数据库。使用该框架后，应用程序中所有数据库操作都通过ORMLite完成，而不需要手工编写任何SQL语句。该方法可以通过减少创建数据库schema的代码数量来节省时间。</p><p>使用ORMLite时最常用的两种注解是 <strong>DatabaseTable</strong> 和 <strong>DatabaseField</strong>。这些注解可以分别用于类及其成员变量，并允许生成最终的数据表。指定 <strong>generatedId=true</strong> 参数，该参数表示该字段是 <strong>主键</strong>。默认情况下，ORMLite使用类名作为SQL表名，使用成员变量名作为表的列名。</p><a id="more"></a><p>开发者需要注意的是ORMLite需要类中提供一个 <strong>无参构造方法</strong>。当ORMLite需要创建类的实例时，ORMLite会使用无参构造方法，并通过反射机制设置成员变量。</p><p>在某些情况下，开发者需要在某张表中保存外部对象的ID，这时需要使用 <strong>foreign=true</strong> 将其标记为 <strong>外键</strong>。更进一步讲，我们要确保父分类必须存在。因此，需要将成员表量声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DatabaseField</span>(foreign = <span class="keyword">true</span>, foreignAutoRefresh = <span class="keyword">true</span>, canBeNull = <span class="keyword">false</span>, uniqueCombo = <span class="keyword">true</span>, columnName = CATEGORY_ID_COLUMN, columnDefinition = <span class="string">"integer references "</span></span><br><span class="line">    + Category.TABLE_NAME</span><br><span class="line">    + <span class="string">"("</span></span><br><span class="line">    + Category.ID_COLUMN</span><br><span class="line">    + <span class="string">") on delete cascade"</span>)</span><br><span class="line"><span class="keyword">private</span> Category category;</span><br></pre></td></tr></table></figure><p>在数据库创建的时候，需要继承 <strong>OrmLiteSqliteOpenHelper</strong> 类，继而重写onCreate()和onUpgrade()方法。<strong>需要注意的是，使用外键时，创建表和删除表的语句有严格的顺序。如果表2中引用了表1数据作为外键，则表2必须在表1创建之后再创建。同理，表2应在表1删除之前删除。</strong></p><p>默认情况下，ORMLite的支持外键的功能并没有开启。要 <strong>支持外键</strong>，需要执行如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onOpen(db);</span><br><span class="line">    db.execSQL(<span class="string">"PRAGMA foreign_keys=ON;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，笔者在学习此项目时遇到了一个关于迭代器的小问题。使用 <strong>Iterator</strong> 类时，当 <strong>hasNext()</strong> 返回false，这个迭代器将调用 <strong>close()</strong> 方法。如果需要在迭代器关闭之前处理迭代器，请确保调用close()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator i = list.iterator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i.hasNext()) &#123;</span><br><span class="line">            process(i.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="keyword">null</span>)  &#123;</span><br><span class="line">            i.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hack42-为SQLite添加自定义功能"><a href="#Hack42-为SQLite添加自定义功能" class="headerlink" title="Hack42 为SQLite添加自定义功能"></a>Hack42 为SQLite添加自定义功能</h3><p><em>问题：SQLite缺乏数学函数，能够支持自定义查询？</em></p><p>解决方案：开发者可以使用 <strong>Android NDK</strong>，加载数据库数据后调用C++代码处理复杂的计算操作。</p><h3 id="Hack43-数据库批处理"><a href="#Hack43-数据库批处理" class="headerlink" title="Hack43 数据库批处理"></a>Hack43 数据库批处理</h3><p><em>问题：Android数据库中大量数据的替换及展示如何处理？</em></p><p>解决方案：使用 <strong>ContentProvider</strong> 处理数据库操作时，可以返回一个 <strong>Cursor</strong>，当数据改变时，该Cursor会随之更新。然而，如果执行了大量数据库操作，Cursor会被频繁更新，这样会使 <strong>UI闪烁</strong>。</p><p>如果直接使用 <strong>contentResolver.insert(NoBatchNumbersContentProvider.CONTENT_URI, cv);</strong> 操作，用户体验很差，因为每执行一次数据插入操作都会提示ContentProvider发生变化，ListView自身也发生刷新；第二种方法是使用 <strong>批量操作</strong>。创建一个 <strong>ContentProviderOperations</strong> 的列表，然后批量处理列表项。然而即使使用了批量操作，闪烁情况照样会出现。因为 <strong>applyBatch()</strong> 方法默认循环遍历每一个操作，同样调用insert方法；<strong>正确的方法是，在ContentProvider的实现代码中对applyBatch()方法做一些修改。</strong> 幸运的是，有开发者已经完成了这部分工作。</p><p><strong>如果要使用批处理操作，需要先继承SQLiteContentProvider。SQLiteContentProvider会将所有操作一并处理，成功后提示UI更新，因此不会发生闪烁的现象。</strong></p><h3 id="Hack44-处理熄灯模式"><a href="#Hack44-处理熄灯模式" class="headerlink" title="Hack44 处理熄灯模式"></a>Hack44 处理熄灯模式</h3><p><em>问题：不同Android版本如何兼容代码？</em></p><p>解决方案：开发者可以根据 <strong>Build.VERSION.SDK_INT</strong> 判断当前设备的Android版本，并根据不同版本运行不同的代码。</p><h3 id="Hack45-在旧版本上使用新API"><a href="#Hack45-在旧版本上使用新API" class="headerlink" title="Hack45 在旧版本上使用新API"></a>Hack45 在旧版本上使用新API</h3><p><em>问题：Android系统版本迭代的过程中，有哪些值得一提的新特性？</em></p><p>解决方案：</p><ul><li>要操作 <strong>SharedPreferences</strong> 类，需要获取一个 <strong>Editor</strong> 类，然后调用方法修改数据。所有相关修改都完成时，需要调用 <strong>commit()</strong> 方法。从Android v9版本开始，SharedPreferences.Editor提供了 <strong>apply()</strong> 方法用于替代 <strong>commit()</strong> 方法。<strong>apply()方法将修改内容提交到SharedPreferences内存缓存中，然后开始异步地将修改提交到存储设备上，可以有效地避免UI线程的耗时操作。</strong></li><li>从Android v8开始，开发者可以向AndroidManifest中添加一个名为 <strong>android:installLocation</strong> 的属性，设置该属性后，应用程序可以安装到SD卡上。</li></ul><h3 id="Hack46-向后兼容的通知"><a href="#Hack46-向后兼容的通知" class="headerlink" title="Hack46 向后兼容的通知"></a>Hack46 向后兼容的通知</h3><p><em>问题：Notification添加动作的功能如何使用？</em></p><p><img src="/assets/blogImg/android_hacks_5_notification.png" alt="为通知添加动作"></p><p>解决方案：Android的Jelly Bean版本发布时引入了新的通知API。通过新API，可以为通知添加动作。通过这些动作，可以在不需要进入应用程序的情况下，对通知做出相应。开发者应使用 <strong>NotificationCompat.Builder.addAction(R.drawable.youricon, ctx.getString(R.string.youraction), yourPendingIntent);</strong> 语句完成通知动作的添加。值得注意的一点是，<strong>部分手机不支持通知动作的添加</strong>，开发者请勿过度依赖该功能。</p><h3 id="Hack47-使用Fragment创建Tab"><a href="#Hack47-使用Fragment创建Tab" class="headerlink" title="Hack47 使用Fragment创建Tab"></a>Hack47 使用Fragment创建Tab</h3><p><em>问题：如何在程序中实现左右滑动切换页面？</em></p><p>解决方案：文中介绍的TabActivity已经是被淘汰的功能，请使用 <strong>ViewPager</strong> 组件实现滑动切换页面的需求。</p><h3 id="Hack48-使用Apache-Maven处理依赖关系"><a href="#Hack48-使用Apache-Maven处理依赖关系" class="headerlink" title="Hack48 使用Apache Maven处理依赖关系"></a>Hack48 使用Apache Maven处理依赖关系</h3><p><em>问题：Android项目如何处理依赖关系？</em></p><p>解决方案：Java项目大部分依然使用Apache Maven处理依赖关系，Android项目应该使用 <strong>Gradle</strong> 处理依赖关系。</p><h3 id="Hack49-在root过的设备上安装依赖库"><a href="#Hack49-在root过的设备上安装依赖库" class="headerlink" title="Hack49 在root过的设备上安装依赖库"></a>Hack49 在root过的设备上安装依赖库</h3><p><em>问题：如何加速依赖库的构建？</em></p><p>解决方案：开发者可以在 <strong>root</strong> 过的设备上提前 <strong>安装依赖库</strong>，从而加速项目的构建速度。</p><h3 id="Hack50-使用Jenkins处理设备多样性"><a href="#Hack50-使用Jenkins处理设备多样性" class="headerlink" title="Hack50 使用Jenkins处理设备多样性"></a>Hack50 使用Jenkins处理设备多样性</h3><p><em>问题：Jenkins如何使用？</em></p><p>解决方案：Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。Jenkins可以帮助开发者完成单元测试、代码分析、管理插件、自定义打包等功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hack41-使用ORMLite构建数据库&quot;&gt;&lt;a href=&quot;#Hack41-使用ORMLite构建数据库&quot; class=&quot;headerlink&quot; title=&quot;Hack41 使用ORMLite构建数据库&quot;&gt;&lt;/a&gt;Hack41 使用ORMLite构建数据库&lt;/h3&gt;&lt;p&gt;&lt;em&gt;问题：Android ORMLite框架如何使用？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解决方案：&lt;strong&gt;ORMLite&lt;/strong&gt; 是一种对象关系映射工具，可用于读写数据库。使用该框架后，应用程序中所有数据库操作都通过ORMLite完成，而不需要手工编写任何SQL语句。该方法可以通过减少创建数据库schema的代码数量来节省时间。&lt;/p&gt;
&lt;p&gt;使用ORMLite时最常用的两种注解是 &lt;strong&gt;DatabaseTable&lt;/strong&gt; 和 &lt;strong&gt;DatabaseField&lt;/strong&gt;。这些注解可以分别用于类及其成员变量，并允许生成最终的数据表。指定 &lt;strong&gt;generatedId=true&lt;/strong&gt; 参数，该参数表示该字段是 &lt;strong&gt;主键&lt;/strong&gt;。默认情况下，ORMLite使用类名作为SQL表名，使用成员变量名作为表的列名。&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>《50 Android Hacks》读书笔记31-40</title>
    <link href="http://www.tingxiangshuixie.com/2017/10/09/50_android_hacks_4/"/>
    <id>http://www.tingxiangshuixie.com/2017/10/09/50_android_hacks_4/</id>
    <published>2017-10-09T09:09:00.000Z</published>
    <updated>2017-10-11T15:15:55.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hack31-Android面向切面编程"><a href="#Hack31-Android面向切面编程" class="headerlink" title="Hack31 Android面向切面编程"></a>Hack31 Android面向切面编程</h3><p><em>问题：Android如何使用切面编程？</em></p><p>解决方案：面向切面编程是一种编程范式，通过分离横切关注点提高程序的模块化和组件化。其基本原理是：<strong>将横切关注点抽离到一个单独的切面中，同时将需要执行的业务逻辑代码放在单独或者不同模块中。</strong></p><p>在Android中可以使用 <strong>AspectJ</strong> 这个库来实现切面编程。在gradle文件中使用 <strong>classpath ‘com.uphyca.gradle:gradle-android-aspectj-plugin:0.9.14’</strong> 构建AspectJ支持。描述切面的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.manning.androidhacks.hack030.MainActivity)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* onCreate(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"mainActivity() &amp;&amp; onCreate()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfterOnCreateOnMainActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"TAG"</span>, <span class="string">"onCreate() has been called!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Hack32-使用Cocos2d-x美化应用程序"><a href="#Hack32-使用Cocos2d-x美化应用程序" class="headerlink" title="Hack32 使用Cocos2d-x美化应用程序"></a>Hack32 使用Cocos2d-x美化应用程序</h3><p><em>问题：Android如何使用Cocos2d-x展示动画？</em></p><p>解决方案：开发者可以使用Android NDK，导入 <strong>org.cocos2dx.lib</strong> 后调用C++代码处理动画效果。</p><h3 id="Hack33-在Android上运行Objective-C"><a href="#Hack33-在Android上运行Objective-C" class="headerlink" title="Hack33 在Android上运行Objective-C"></a>Hack33 在Android上运行Objective-C</h3><p><em>问题：Android如何运行Objective-C？</em></p><p>解决方案：<strong>Itoa</strong> 是一组托管于Github的开源项目，该项目实现了编译器、构建脚本和各种库，用于将Objective-C源代码构建为Android APK文件。</p><h3 id="Hack34-在Android上运行Scala"><a href="#Hack34-在Android上运行Scala" class="headerlink" title="Hack34 在Android上运行Scala"></a>Hack34 在Android上运行Scala</h3><p><em>问题：Android如何运行Scala？</em></p><p>解决方案：开发者可以使用 <strong>Simple Build Tool</strong> 这个开源的Scala构建工具处理Android项目中的Scala代码。</p><h3 id="Hack35-同时发起多个Intent"><a href="#Hack35-同时发起多个Intent" class="headerlink" title="Hack35 同时发起多个Intent"></a>Hack35 同时发起多个Intent</h3><p><em>问题：用户发布图片时，拍照或选择图片两种Intent如何合并？</em></p><p>解决方案：<strong>Intent.createChooser()</strong> 和 <strong>putExtra()</strong> 方法可以合并多个Intent。核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Intent pickIntent = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">pickIntent.setType(<span class="string">"image/*"</span>);</span><br><span class="line"></span><br><span class="line">Intent takePhotoIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line"></span><br><span class="line">Intent chooserIntent = Intent.createChooser(pickIntent, getString(R.string.activity_main_pick_both));</span><br><span class="line">chooserIntent.putExtra(Intent.EXTRA_INITIAL_INTENTS, <span class="keyword">new</span> Intent[] &#123; takePhotoIntent &#125;);</span><br><span class="line"></span><br><span class="line">startActivityForResult(chooserIntent, PICK_OR_TAKE_PICTURE);</span><br></pre></td></tr></table></figure><h3 id="Hack36-在用户反馈中收集信息"><a href="#Hack36-在用户反馈中收集信息" class="headerlink" title="Hack36 在用户反馈中收集信息"></a>Hack36 在用户反馈中收集信息</h3><p><em>问题：如何获取到用户的设备信息？</em></p><p>解决方案：关注用户反馈是确保应用程序成功的有效方式之一。如果用户需要发送反馈邮件，最好的处理方式是在反馈邮件中附加用户的设备信息。这意味着，从用户中获取一些重要的详细信息变得比较简单了。开发者需要创建 <strong>EnvironmentInfoUtil</strong> 工具类来收集用户设备信息，并将其添加到Email的 <strong>EXTRA_TEXT</strong> 并发送。</p><h3 id="Hack37-向media-ContentProvider添加MP3文件"><a href="#Hack37-向media-ContentProvider添加MP3文件" class="headerlink" title="Hack37 向media ContentProvider添加MP3文件"></a>Hack37 向media ContentProvider添加MP3文件</h3><p><em>问题：添加媒体文件后，如何通知ContentProvider？</em></p><p>解决方案：添加媒体文件成功后，通过 <strong>sendBroadcast()</strong> 方法发送广播。</p><h3 id="Hack38-为ActionBar添加刷新动作"><a href="#Hack38-为ActionBar添加刷新动作" class="headerlink" title="Hack38 为ActionBar添加刷新动作"></a>Hack38 为ActionBar添加刷新动作</h3><p><em>问题：ActionBar如何使用？</em></p><p>解决方案：在Android 3.0之后，Google对UI导航设计上进行了一系列的改革，其中有一个非常好用的新功能就是引入的 <strong>ActionBar</strong>，它用于取代3.0之前的标题栏，并提供更为丰富的导航效果。</p><p>重写 <strong>onCreateOptionsMenu()</strong> 和 <strong>onOptionsItemSelected()</strong> 方法，设置ActionBar的显示效果与点击事件。</p><h3 id="Hack39-从Market中获取依赖功能"><a href="#Hack39-从Market中获取依赖功能" class="headerlink" title="Hack39 从Market中获取依赖功能"></a>Hack39 从Market中获取依赖功能</h3><p><em>问题：如何完成在当前程序中打开其他应用程序（如果设备上没有该应用则跳转到应用商店下载）的需求？</em></p><p>解决方案：开发者首先应根据 <strong>程序包名</strong> 判断该应用是否安装在设备中，如果已经安装则通过Intent打开即可。反之，则通过 <strong>AlertDialog</strong> 打开Market。</p><h3 id="Hack40-以后进先出方式加载图片"><a href="#Hack40-以后进先出方式加载图片" class="headerlink" title="Hack40 以后进先出方式加载图片"></a>Hack40 以后进先出方式加载图片</h3><p><em>问题：默认情况下，列表是没有选择行为的。如何设置列表的选择模式？</em></p><p>解决方案：AsyncTask并不适合处理大量图片，也不会让开发者控制任务的优先级。作为替代方案，我们使用 <strong>java.util.concurrent</strong> 包中的执行器服务和一个优先级队列来指定请求图片的顺序。</p><p>从开发者的角度来说，每次加载大量图片并不是一个非常合理的行为，UI很有可能不会灵敏响应。从用户的角度来说，大量图片的加载体验也很一般。<strong>通用的设计方式是，大量图片分页加载，为图片列表提供下拉刷新和上划加载更多功能。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hack31-Android面向切面编程&quot;&gt;&lt;a href=&quot;#Hack31-Android面向切面编程&quot; class=&quot;headerlink&quot; title=&quot;Hack31 Android面向切面编程&quot;&gt;&lt;/a&gt;Hack31 Android面向切面编程&lt;/h3&gt;&lt;p&gt;&lt;em&gt;问题：Android如何使用切面编程？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解决方案：面向切面编程是一种编程范式，通过分离横切关注点提高程序的模块化和组件化。其基本原理是：&lt;strong&gt;将横切关注点抽离到一个单独的切面中，同时将需要执行的业务逻辑代码放在单独或者不同模块中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Android中可以使用 &lt;strong&gt;AspectJ&lt;/strong&gt; 这个库来实现切面编程。在gradle文件中使用 &lt;strong&gt;classpath ‘com.uphyca.gradle:gradle-android-aspectj-plugin:0.9.14’&lt;/strong&gt; 构建AspectJ支持。描述切面的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LogAspect&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Pointcut&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;within(com.manning.androidhacks.hack030.MainActivity)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mainActivity&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Pointcut&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;execution(* onCreate(..))&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AfterReturning&lt;/span&gt;(pointcut = &lt;span class=&quot;string&quot;&gt;&quot;mainActivity() &amp;amp;&amp;amp; onCreate()&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;logAfterOnCreateOnMainActivity&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;onCreate() has been called!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>《50 Android Hacks》读书笔记21-30</title>
    <link href="http://www.tingxiangshuixie.com/2017/09/29/50_android_hacks_3/"/>
    <id>http://www.tingxiangshuixie.com/2017/09/29/50_android_hacks_3/</id>
    <published>2017-09-29T14:38:00.000Z</published>
    <updated>2017-10-11T15:15:20.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hack21-与Activity生命周期绑定的Broadcast-Receiver"><a href="#Hack21-与Activity生命周期绑定的Broadcast-Receiver" class="headerlink" title="Hack21 与Activity生命周期绑定的Broadcast Receiver"></a>Hack21 与Activity生命周期绑定的Broadcast Receiver</h3><p><em>问题：在Activity中使用Broadcast Receiver对象监听广播需要注意什么？</em></p><p>解决方案：在Activity中自定义 <strong>Broadcast Receiver</strong>，重写 <strong>onReceive()</strong> 方法，根据接收到的广播执行代码。<strong>要注意根据Activity的生命周期决定Broadcast Receiver的生命周期。</strong></p><a id="more"></a><h3 id="Hack22-使用Android库项目时适用的架构模式"><a href="#Hack22-使用Android库项目时适用的架构模式" class="headerlink" title="Hack22 使用Android库项目时适用的架构模式"></a>Hack22 使用Android库项目时适用的架构模式</h3><p><em>问题：Android项目间如何共享代码？</em></p><p>解决方案：在以前使用Eclipse的时候，开发者需要手动引入Jar文件，非常麻烦。Android Studio使用 <strong>Gradle</strong> 作为项目构建工具，能够提供最大的便利去构建工程。如果某个项目并没有提供相关的依赖包，Android Studio可以直接把该项目以 <strong>Module</strong> 的形式引入，两个Module之间的代码可以共享。</p><h3 id="Hack23-同步适配器模式"><a href="#Hack23-同步适配器模式" class="headerlink" title="Hack23 同步适配器模式"></a>Hack23 同步适配器模式</h3><p><em>问题：同步适配器如何使用？</em></p><p>解决方案：同步适配器框架是Android提供的一套移动端与服务端数据同步的解决方案，它具有以下优点——插件化结构、自动执行、自动检测网络、省电、有账户认证机制等。最常见的是用于备份，联系人同步等各种云同步功能。</p><p>SyncAdapter依赖于自定义账户和ContentProvider。<strong>SyncAdapter</strong> 类继承自 <strong>AbstractThreadedSyncAdapter</strong>，在构造方法中初始化需要用到的组件，比如初始化一个ContentResolver。除了构造方法外只有 <strong>onPerformSync()</strong> 方法需要实现，这是真正要运行的同步方法，这个方法运行在独立的线程中，其中可以进行联网耗时操作。</p><h3 id="Hack24-处理空列表"><a href="#Hack24-处理空列表" class="headerlink" title="Hack24 处理空列表"></a>Hack24 处理空列表</h3><p><em>问题：使用列表展示数据时，列表为空怎么办？</em></p><p>解决方案：在布局文件中，编写列表为空时要显示的TextView或ImageView，并设置其为 <strong>android:visibility=”gone”</strong>。在加载数据后判断列表是否为空，如果为空则将其显示出来。</p><h3 id="Hack25-通过ViewHolder优化适配器"><a href="#Hack25-通过ViewHolder优化适配器" class="headerlink" title="Hack25 通过ViewHolder优化适配器"></a>Hack25 通过ViewHolder优化适配器</h3><p><em>问题：ViewHolder怎么用？</em></p><p>解决方案：ListView已经很少被使用，在此我们讨论 <strong>RecyclerView</strong> 中ViewHolder的使用方式。Adapter对象是ListView和底层数据间的桥梁。Adapter用于访问数据项，并且负责为数据项生成视图。在RecyclerView中，<strong>Adapter</strong> 像是 <strong>ViewHolder的集合</strong>，ViewHolder负责绑定列表中的条目视图，而且可以被 <strong>回收</strong> 循环使用。</p><h3 id="Hack26-为ListView添加分段标头"><a href="#Hack26-为ListView添加分段标头" class="headerlink" title="Hack26 为ListView添加分段标头"></a>Hack26 为ListView添加分段标头</h3><p><em>问题：带有分段标头的列表如何创建？</em></p><p>解决方案：在每个 <strong>ListItem</strong> 中加入一个 <strong>TextView</strong> 作为 <strong>Header</strong>，根据其首字母与前一项首字母相等与否决定Header是否可见。在ListView上方设置一个Header，获取页面最上方的Item的position，将其首字母设为最上方Header显示的内容。</p><h3 id="Hack27-使用Activity和Delegate与适配器交互"><a href="#Hack27-使用Activity和Delegate与适配器交互" class="headerlink" title="Hack27 使用Activity和Delegate与适配器交互"></a>Hack27 使用Activity和Delegate与适配器交互</h3><p><em>问题：委托模式如何使用？</em></p><p>解决方案：委托模式是软件设计模式中的一项基本技巧。<strong>在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</strong></p><p>在本项目中，所有业务逻辑从适配器中移到Activity中，通过一个委托接口调用Activity的方法删除对象。而当适配器需要使用Activity中的方法时，直接使用委托对象进行操作。实际上，传入的委托对象正是实现了 <strong>NumbersAdapterDelegate</strong> 接口的 <strong>Activity</strong>。</p><p><strong>委托模式有效地避免了继承的滥用。</strong></p><h3 id="Hack28-充分利用ListView的头视图"><a href="#Hack28-充分利用ListView的头视图" class="headerlink" title="Hack28 充分利用ListView的头视图"></a>Hack28 充分利用ListView的头视图</h3><p><em>问题：ListView头视图如何使用？</em></p><p>解决方案：其实 <strong>HeaderView</strong> 实际上也是Item的一种，只不过显示在顶部的位置，那么我们完全可以通过为其设置 <strong>ItemType</strong> 来完成。比较常见的实现方式为：继承 <strong>RecyclerView.Adapter</strong> 类并重写 <strong>onCreateViewHolder()</strong>、<strong>getItemViewType()</strong>、<strong>onBindViewHolder()</strong> 等方法，最后添加 <strong>addHeaderView()</strong>、<strong>getHeadersCount()</strong> 等方法。</p><h3 id="Hack29-在ViewPager中处理转屏"><a href="#Hack29-在ViewPager中处理转屏" class="headerlink" title="Hack29 在ViewPager中处理转屏"></a>Hack29 在ViewPager中处理转屏</h3><p><em>问题：在Activity中如何处理转屏？</em></p><p>解决方案：可以在Activity中使用 <strong>setRequestedOrientation()</strong> 方法强制改变屏幕方向，但除了播放视频、开启游戏等情况以外，请勿轻易改变屏幕方向以免引起用户反感。</p><h3 id="Hack30-ListView的选择模式"><a href="#Hack30-ListView的选择模式" class="headerlink" title="Hack30 ListView的选择模式"></a>Hack30 ListView的选择模式</h3><p><em>问题：默认情况下，列表是没有选择行为的。如何设置列表的选择模式？</em></p><p>解决方案：ListView中 <strong>choiceMode</strong> 属性可以设置列表的选择行为，如果需要ListView处理 <strong>选择行为</strong>，还需要创建自定义视图并实现 <strong>Checkable</strong> 接口。<strong>CheckBox是可获取焦点的控件，如果需要扩展其点击事件，则需将其设置为不允许获取焦点。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:clickable="false"</span><br><span class="line">android:focusable="false"</span><br><span class="line">android:focusableInTouchMode="false"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hack21-与Activity生命周期绑定的Broadcast-Receiver&quot;&gt;&lt;a href=&quot;#Hack21-与Activity生命周期绑定的Broadcast-Receiver&quot; class=&quot;headerlink&quot; title=&quot;Hack21 与Activity生命周期绑定的Broadcast Receiver&quot;&gt;&lt;/a&gt;Hack21 与Activity生命周期绑定的Broadcast Receiver&lt;/h3&gt;&lt;p&gt;&lt;em&gt;问题：在Activity中使用Broadcast Receiver对象监听广播需要注意什么？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解决方案：在Activity中自定义 &lt;strong&gt;Broadcast Receiver&lt;/strong&gt;，重写 &lt;strong&gt;onReceive()&lt;/strong&gt; 方法，根据接收到的广播执行代码。&lt;strong&gt;要注意根据Activity的生命周期决定Broadcast Receiver的生命周期。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>《50 Android Hacks》读书笔记11-20</title>
    <link href="http://www.tingxiangshuixie.com/2017/09/27/50_android_hacks_2/"/>
    <id>http://www.tingxiangshuixie.com/2017/09/27/50_android_hacks_2/</id>
    <published>2017-09-27T09:35:00.000Z</published>
    <updated>2018-03-11T06:52:14.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hack11-为文本添加发亮的效果"><a href="#Hack11-为文本添加发亮的效果" class="headerlink" title="Hack11 为文本添加发亮的效果"></a>Hack11 为文本添加发亮的效果</h3><p><em>问题：如何设计一个显示高亮绿灯的数字时钟？</em></p><p><img src="/assets/blogImg/android_hacks_4_clock.png" alt="数字时钟"></p><a id="more"></a><p>解决方案：应先继承TextView类，并为其设置 <strong>digital-7.ttf</strong> 字体。在背景文件中添加两个TextView标签，第一个显示 <strong>88:88:88的阴影</strong>（半透明效果），第二个用于显示 <strong>当前时间</strong>。布局代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.manning.androidhacks.hack011.view.LedTextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/default_time"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#3300ff00"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"80sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.manning.androidhacks.hack011.view.LedTextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/main_clock_time"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowColor</span>=<span class="string">"#00ff00"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowDx</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowDy</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowRadius</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#00ff00"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"80sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 <strong>android:shadowDx</strong> 和 <strong>android:shadowDy</strong> 属性的值可以改变阴影与文本之间的偏移。指定 <strong>android:shadowRadius</strong> 属性可以让用户产生一种 <strong>文本更亮</strong> 的错觉。为了产生一种发亮的效果，我们没有使用android:shadowDx和android:shadowDy属性，而是通过修改android:shadowRadius属性。</p><h3 id="Hack12-为背景添加圆角边框"><a href="#Hack12-为背景添加圆角边框" class="headerlink" title="Hack12 为背景添加圆角边框"></a>Hack12 为背景添加圆角边框</h3><p><em>问题：如何为TextView、Button等控件添加圆角边框？</em></p><p>解决方案：可以修改控件的 <strong>background</strong> 或 <strong>style</strong> 属性，将其指定为 <strong>带有shape标签</strong> 的drawable文件。值得一提的是，在Android 5.0中出现了一个全新的控件——<strong>CardView</strong>。CardView被包装为一种布局，拥有多种圆角、阴影以及点击效果，可以给使用者带来非常好的交互体验。</p><h3 id="Hack13-在onCreate-方法中获取View的宽度和高度"><a href="#Hack13-在onCreate-方法中获取View的宽度和高度" class="headerlink" title="Hack13 在onCreate()方法中获取View的宽度和高度"></a>Hack13 在onCreate()方法中获取View的宽度和高度</h3><p><em>问题：为什么onCreate()方法调用getWidth()和getHeight()方法返回值都是0？</em></p><p>解决方案：在onCreate()方法中直接调用 <strong>getWidth()</strong> 和 <strong>getHeight()</strong> 方法时，视图正处于绘制阶段。只有在整个布局绘制完毕后，视图才能得到自身的宽和高，这个过程发生在onCreate()方法之后。开发者应通过View的 <strong>post()</strong> 方法解决该问题。</p><h3 id="Hack14-VideoView的转屏处理技巧"><a href="#Hack14-VideoView的转屏处理技巧" class="headerlink" title="Hack14 VideoView的转屏处理技巧"></a>Hack14 VideoView的转屏处理技巧</h3><p><em>问题：如何处理视频的转屏操作？</em></p><p>解决方案：首先，要让Activity能够处理转屏操作。要实现这个功能，需要在AndroidManifest.xml文件中相应的Activity标签中添加 <strong>android:configChanges=”orientation”</strong> 属性。配置该属性后，当屏幕旋转时，系统不会重启Activity，而是调用该Activity的 <strong>onConfigurationChanged()</strong> 方法。重写onConfigurationChanged()方法，在其中调用setVideoViewPosition()方法。在setVideoViewPosition()方法中，判断屏幕的朝向并根据结果对VideoView的位置做不同的处理。</p><h3 id="Hack15-移除背景以提升Activity启动速度"><a href="#Hack15-移除背景以提升Activity启动速度" class="headerlink" title="Hack15 移除背景以提升Activity启动速度"></a>Hack15 移除背景以提升Activity启动速度</h3><p><em>问题：有什么方法能提高复杂视图树的加载速度？</em></p><p>解决方案：Android SDK中提供了 <strong>Hierarchy Viewer</strong> 工具，该工具可以用来检测未被使用的视图以减少视图树的层次。<strong>DecorView</strong> 是视图树的根节点，默认情况下框架层会以默认背景色填充窗口，而DecorView就是持有默认窗口背景图片的视图。<strong>如果使用不透明的界面或者自定义背景，那么就可以将Activity标签中的windowBackground属性设置为null。</strong></p><h3 id="Hack16-更改Toast显示位置的技巧"><a href="#Hack16-更改Toast显示位置的技巧" class="headerlink" title="Hack16 更改Toast显示位置的技巧"></a>Hack16 更改Toast显示位置的技巧</h3><p><em>问题：如何修改Toast显示的位置？</em></p><p>解决方案：开发者可以使用 <strong>Toast.setGravity()</strong> 方法改变Toast默认位置。</p><h3 id="Hack17-使用Gallery创建向导表单"><a href="#Hack17-使用Gallery创建向导表单" class="headerlink" title="Hack17 使用Gallery创建向导表单"></a>Hack17 使用Gallery创建向导表单</h3><p><em>问题：当需要用户填充一个较长的表单时，有什么好的设计方式？</em></p><p>解决方案：利用 <strong>Gallery</strong> 中的自定义视图创建一个向导表单，并通过Adapter进行数据绑定。</p><h3 id="Hack18-在发布正式版本前移除日志语句"><a href="#Hack18-在发布正式版本前移除日志语句" class="headerlink" title="Hack18 在发布正式版本前移除日志语句"></a>Hack18 在发布正式版本前移除日志语句</h3><p><em>问题：在开发过程中，开发者可能会打印一些日志来检查请求是否成功。有什么在发布正式版本前移除日志的办法？</em></p><p>解决方案：<strong>ProGuard工具</strong> 可以移除不必要的代码，或者使用语义模糊的名称来重命名类、方法和变量，以此达到 <strong>压缩</strong>、<strong>优化</strong> 和 <strong>混淆</strong> 代码的目的。在Android Studio中，<strong>build.gradle文件内proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.txt’语句指定了ProGuard工具的执行目标</strong>。下面是常用proguard-rules的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#指定代码的压缩级别</span><br><span class="line">-optimizationpasses 5</span><br><span class="line"> </span><br><span class="line">#包名不混合大小写</span><br><span class="line">-dontusemixedcaseclassnames</span><br><span class="line"> </span><br><span class="line">#不忽略非公共的库类</span><br><span class="line">-dontskipnonpubliclibraryclasses</span><br><span class="line"></span><br><span class="line">#不预校验</span><br><span class="line">-dontpreverify</span><br><span class="line"></span><br><span class="line">#屏蔽警告</span><br><span class="line">-ignorewarnings </span><br><span class="line"> </span><br><span class="line">#混淆时记录日志</span><br><span class="line">-verbose</span><br><span class="line"> </span><br><span class="line">#混淆时所采用的算法</span><br><span class="line">-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*</span><br><span class="line"> </span><br><span class="line">#保护注解</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line"> </span><br><span class="line"># 保持哪些类不被混淆</span><br><span class="line">-keep public class * extends android.app.Fragment</span><br><span class="line">-keep public class * extends android.app.Activity</span><br><span class="line">-keep public class * extends android.app.Application</span><br><span class="line">-keep public class * extends android.app.Service</span><br><span class="line">-keep public class * extends android.content.BroadcastReceiver</span><br><span class="line">-keep public class * extends android.content.ContentProvider</span><br><span class="line">-keep public class * extends android.app.backup.BackupAgentHelper</span><br><span class="line">-keep public class * extends android.preference.Preference</span><br><span class="line">-keep public class com.android.vending.licensing.ILicensingService</span><br><span class="line">-keep class android.support.v4.** &#123; *; &#125;</span><br><span class="line">-keep class android.support.v7.** &#123; *; &#125;</span><br><span class="line"></span><br><span class="line">#保持 native 方法不被混淆</span><br><span class="line">-keepclasseswithmembernames class * &#123;</span><br><span class="line">    native &lt;methods&gt;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#保持自定义控件类不被混淆</span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#保持自定义控件类不被混淆</span><br><span class="line">-keepclasseswithmembers class * &#123;</span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#保持自定义控件类不被混淆</span><br><span class="line">-keepclassmembers class * extends android.app.Activity &#123;</span><br><span class="line">   public void *(android.view.View);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#保持 Parcelable 不被混淆</span><br><span class="line">-keep class * implements android.os.Parcelable &#123;</span><br><span class="line">  public static final android.os.Parcelable$Creator *;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#保持 Serializable 不被混淆</span><br><span class="line">-keepnames class * implements java.io.Serializable</span><br><span class="line"> </span><br><span class="line">#保持 Serializable 不被混淆并且enum 类也不被混淆</span><br><span class="line">-keepclassmembers class * implements java.io.Serializable &#123;</span><br><span class="line">    static final long serialVersionUID;</span><br><span class="line">    private static final java.io.ObjectStreamField[] serialPersistentFields;</span><br><span class="line">    !static !transient &lt;fields&gt;;</span><br><span class="line">    !private &lt;fields&gt;&lt;span&gt;&lt;/span&gt;;</span><br><span class="line">    !private &lt;methods&gt;;</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream);</span><br><span class="line">    private void readObject(java.io.ObjectInputStream);</span><br><span class="line">    java.lang.Object writeReplace();</span><br><span class="line">    java.lang.Object readResolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#不混淆资源类</span><br><span class="line">-keepclassmembers class **.R$* &#123;</span><br><span class="line">    public static &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#避免混淆泛型 如果混淆报错建议关掉</span><br><span class="line">-keepattributes Signature</span><br><span class="line"> </span><br><span class="line">#移除Log</span><br><span class="line">-assumenosideeffects class android.util.Log &#123;</span><br><span class="line">    public static int v(...);</span><br><span class="line">    public static int i(...);</span><br><span class="line">    public static int w(...);</span><br><span class="line">    public static int d(...);</span><br><span class="line">    public static int e(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hack19-使用Hierarchy-Viewer工具移除不必要的视图"><a href="#Hack19-使用Hierarchy-Viewer工具移除不必要的视图" class="headerlink" title="Hack19 使用Hierarchy Viewer工具移除不必要的视图"></a>Hack19 使用Hierarchy Viewer工具移除不必要的视图</h3><p><em>问题：如何找出视图树中那些不必要的视图以及性能瓶颈？</em></p><p>解决方案：Android SDK中提供了 <strong>Hierarchy Viewer</strong> 工具，可以用来查看视图树并分析视图树中各个视图在测量、布局、绘制阶段所消耗的时间。View节点中带有红色或黄色的点代表速度较慢的View对象。请注意，低性能并不表示一定有问题，特别像是ViewGroup对象，View的子节点越多，结构越复杂，性能越差。<br>该工具还可以帮助开发者找到性能问题，只要察看每个View节点的性能指标（颜色点）就可以，你可以看到测量、布局或绘制最慢的View对象是哪个，这样就能快速确定要优先判断哪里出了问题。</p><p>请注意：出于安全性的考虑，Hierarchy Viewer只能连接 <strong>Android开发版手机</strong> 或是 <strong>模拟器</strong>。Hierarchy Viewer在连接手机时，手机上必须启动一个叫 <strong>View Server</strong> 的客户端与其进行socket通信。而在商业手机上，是无法开启View Server的，故Hierarchy Viewer无法连接到普通的商业手机。 </p><h3 id="Hack20-模型-视图-主导器（MVP）模式"><a href="#Hack20-模型-视图-主导器（MVP）模式" class="headerlink" title="Hack20 模型-视图-主导器（MVP）模式"></a>Hack20 模型-视图-主导器（MVP）模式</h3><p><em>问题：MVP模式是什么？与MVC模式有怎样的区别？</em></p><p>解决方案：MVP模式是MVC模式在Android上的一种变体，要介绍MVP模式就得先说说MVC模式。在 <strong>MVC模式</strong> 中，Activity应该是属于 <strong>View</strong> 这一层。而实质上，它既担任了View的角色，同时也包含一些Controller的东西在里面。这对于开发与维护来说不太友好，耦合度很高。把Activity的 <strong>View</strong> 和 <strong>Controller</strong> 抽离出来就变成了 <strong>View</strong> 和 <strong>Presenter</strong>，这就是 <strong>MVP模式</strong>。</p><p>MVP的好处大体来说有以下3点：</p><ol><li>Activity代码变得更加简洁。使用MVP模式之后，Activity就能瘦身许多了。<strong>每个Activity基本上只有FindView、SetListener以及Init的代码，其他的就是对Presenter的调用以及对View接口的实现。</strong> 这种情形下阅读代码就容易多了，而且开发者只要看Presenter的接口，就能明白这个模块都有哪些业务，很快就能定位到具体代码。Activity变得容易维护，以后要调整业务、增删功能也就变得简单许多。</li><li>方便进行单元测试。MVP模式中，由于业务逻辑都在Presenter里，开发者完全可以写一个PresenterTest的实现类继承Presenter的接口。只要在Activity里把Presenter的创建换成PresenterTest，就能进行单元测试了，测试完再换回来即可。</li><li>避免Activity的内存泄露。<strong>Android APP发生OOM的最大原因就是出现内存泄露造成APP的内存不够用，而造成内存泄露的两大原因之一就是Activity泄露和Bitmap泄露。</strong> Activity是有生命周期的，用户随时可能切换Activity，当APP的内存不够用的时候，系统会回收处于后台的Activity的资源以避免OOM。采用传统的MVC模式，一大堆异步任务和对UI的操作都放在Activity里面。比如用户可能从网络下载一张图片，在下载成功的回调里把图片加载到Activity的ImageView里面，所以异步任务保留着对Activity的引用。这样一来，即使Activity已经被切换到后台（onDestroy方法已经执行），这些异步任务仍然保留着对Activity实例的引用，所以系统就无法回收这个Activity实例了，结果就是Activity泄露。Android的组件中，Activity对象往往是在堆里占最多内存的，所以系统会优先回收Activity对象。如果出现Activity泄露，应用程序很容易因为内存不够而OOM。采用MVP模式，只要在当前的Activity的onDestroy方法里，分离异步任务对Activity的引用，就能避免Activity泄露。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hack11-为文本添加发亮的效果&quot;&gt;&lt;a href=&quot;#Hack11-为文本添加发亮的效果&quot; class=&quot;headerlink&quot; title=&quot;Hack11 为文本添加发亮的效果&quot;&gt;&lt;/a&gt;Hack11 为文本添加发亮的效果&lt;/h3&gt;&lt;p&gt;&lt;em&gt;问题：如何设计一个显示高亮绿灯的数字时钟？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/blogImg/android_hacks_4_clock.png&quot; alt=&quot;数字时钟&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>《50 Android Hacks》读书笔记1-10</title>
    <link href="http://www.tingxiangshuixie.com/2017/09/22/50_android_hacks_1/"/>
    <id>http://www.tingxiangshuixie.com/2017/09/22/50_android_hacks_1/</id>
    <published>2017-09-22T09:34:00.000Z</published>
    <updated>2017-09-26T14:43:32.074Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近来发现一本非常好的Android工具书——<strong>《50 Android Hacks》</strong>，中文译名叫做 <strong>《Android开发必知的50个诀窍》</strong>。与其他开发类书籍不同的是，该书并不是系统地讲解每一个知识点，而是以 <strong>问题/解决方案</strong> 的形式提出开发过程中遇到的问题，并编写Demo程序给出合理的解决方案。本书适用于已经学习过Android开发的程序员，且每个项目对应的源代码都可以在<a href="https://github.com/Macarse/50AH-code" target="_blank" rel="noopener">Github 50AH-code</a> 中下载。</p></blockquote><p>对于笔者这种对Android开发有一定了解、希望学习到更好的解决方案的程序员来说，这本书非常受用。书中每一节内容对应一个Demo，简单粗暴地印证了 <strong>「Talk is cheap. Show me the code.」</strong> 这句名言。在此，我将书中值得注意的地方整理出来，以免遗忘。</p><a id="more"></a><h3 id="Hack1-使用weight属性实现视图的居中显示"><a href="#Hack1-使用weight属性实现视图的居中显示" class="headerlink" title="Hack1 使用weight属性实现视图的居中显示"></a>Hack1 使用weight属性实现视图的居中显示</h3><p><em>问题：无论手机在水平还是竖直情况下，如何固定某View占据父视图的宽度（或高度）百分比？</em></p><p>解决方案：利用ViewGroup的 <strong>weightSum</strong> 属性和子View的 <strong>layout_weight</strong> 属性设定View在ViewGroup中的百分比宽度或高度。</p><h3 id="Hack2-使用延迟加载以及避免代码重复"><a href="#Hack2-使用延迟加载以及避免代码重复" class="headerlink" title="Hack2 使用延迟加载以及避免代码重复"></a>Hack2 使用延迟加载以及避免代码重复</h3><p><em>问题：构建一些相似的布局布局时，开发者是否可以使用同一套代码？有什么方法可以实现大型组件的“懒加载”？</em></p><p>解决方案：布局中可以直接使用&lt;include/&gt;标签引入其他layout文件，还可以在其中指定属性或修改属性值。加载某些不需要立即呈现或用户可能并不需要的组件时，可以通过ViewStub实现View的延迟加载。ViewStub是一种不可见并且大小为0的视图，可以延迟到运行时填充布局资源。<strong>当ViewStub设置被可视或者inflate()方法被调用后，就会填充布局资源。</strong></p><h3 id="Hack3-创建定制的ViewGroup"><a href="#Hack3-创建定制的ViewGroup" class="headerlink" title="Hack3 创建定制的ViewGroup"></a>Hack3 创建定制的ViewGroup</h3><p><em>问题：当View大体相同但所处位置按规律排列时，有什么更好构建布局的方式？</em></p><p><img src="/assets/blogImg/android_hacks_1_poker.png" alt="扑克牌布局"></p><p>解决方案：当View大体相同时，可以使用自定义ViewGroup，更易于项目的维护。<strong>修改onMeasure()方法实现ViewGroup对其中View的位置及大小的测量，修改onLayout()方法实现子View的绘制。</strong></p><h3 id="Hack4-偏好设置使用技巧"><a href="#Hack4-偏好设置使用技巧" class="headerlink" title="Hack4 偏好设置使用技巧"></a>Hack4 偏好设置使用技巧</h3><p><em>问题：能否使用系统的设置界面主题为应用程序列表美化？</em></p><p>解决方案：利用带有 <strong>PreferenceScreen</strong> 的XML文件完成布局，代码及Nexus S API 24运行样式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PreferenceScreen</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:key</span>=<span class="string">"pref_first_preferencescreen_key"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:title</span>=<span class="string">"Preferences"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">PreferenceCategory</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditTextPreference</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:key</span>=<span class="string">"pref_username"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:summary</span>=<span class="string">"Username:"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Username"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PreferenceCategory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">PreferenceCategory</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"Application"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Preference</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:key</span>=<span class="string">"pref_rate"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:summary</span>=<span class="string">"Rate the app in the store!"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Rate the app"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Preference</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:key</span>=<span class="string">"pref_share"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:summary</span>=<span class="string">"Share the app with your friends"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Share it"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.manning.androidhacks.hack004.preference.EmailDialog</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:dialogIcon</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:dialogTitle</span>=<span class="string">"Send Feedback"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:dialogMessage</span>=<span class="string">"Do you want to send an email with feedback?"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:key</span>=<span class="string">"pref_sendemail_key"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:negativeButtonText</span>=<span class="string">"Cancel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:positiveButtonText</span>=<span class="string">"OK"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:summary</span>=<span class="string">"Send your feedback by e-mail"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"Send Feedback"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.manning.androidhacks.hack004.preference.AboutDialog</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:dialogIcon</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:dialogTitle</span>=<span class="string">"About"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:key</span>=<span class="string">"pref_about_key"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:negativeButtonText</span>=<span class="string">"@null"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:title</span>=<span class="string">"About"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PreferenceCategory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">PreferenceScreen</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blogImg/android_hacks_2_preference.png" alt="Preference布局"></p><p>另外，可以实现 <strong>OnSharedPreferenceChangeListener</strong> 接口来监测EditTextPreference中的文字的变化。</p><h3 id="Hack5-使用TextSwitcher和ImageSwitcher实现平滑过渡"><a href="#Hack5-使用TextSwitcher和ImageSwitcher实现平滑过渡" class="headerlink" title="Hack5 使用TextSwitcher和ImageSwitcher实现平滑过渡"></a>Hack5 使用TextSwitcher和ImageSwitcher实现平滑过渡</h3><p><em>问题：如何提升TextView、ImageView等组件切换内容的视觉体验？</em></p><p>解决方案：使用 <strong>TextSwitcher</strong> 和 <strong>ImageSwitcher</strong> 添加换入和换出的动画效果，实现平滑过渡。该项目中使用android.R.anim.fade_in和android.R.anim.fade_out添加了淡入淡出效果。</p><h3 id="Hack6-为ViewGroup的子视图添加悦目的动画效果"><a href="#Hack6-为ViewGroup的子视图添加悦目的动画效果" class="headerlink" title="Hack6 为ViewGroup的子视图添加悦目的动画效果"></a>Hack6 为ViewGroup的子视图添加悦目的动画效果</h3><p><em>问题：如何提升ListView等组件加载内容的视觉体验？</em></p><p>解决方案：可以使用 <strong>ListView.setLayoutAnimation(new LayoutAnimationController(AnimationUtils.loadAnimation(this, R.anim.list_animation), delay))</strong> 方法为ListView的每个条目添加透明度渐变动画和位移动画。值得一提的是，<strong>Android坐标系原点在屏幕的左上角</strong>，项目中从上而下位移到指定位置的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"50"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYDelta</span>=<span class="string">"-100%"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYDelta</span>=<span class="string">"0%"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/assets/blogImg/android_hacks_3_coordinate.png" alt="Android手机屏幕坐标系"></p><h3 id="Hack7-在Canvas上显示动画"><a href="#Hack7-在Canvas上显示动画" class="headerlink" title="Hack7 在Canvas上显示动画"></a>Hack7 在Canvas上显示动画</h3><p><em>问题：有没有API可以直接在Android屏幕上绘图？</em></p><p>解决方案：Canvas类封装了所有绘图调用，我们可以 <strong>继承View类并重写其onDraw()方法</strong>，从而进行图像的绘制以及完成一些动画效果。笔者接下来会结合此项目源码设计并实现一款小游戏。</p><h3 id="Hack8-附加Ken-Burns特效的幻灯片"><a href="#Hack8-附加Ken-Burns特效的幻灯片" class="headerlink" title="Hack8 附加Ken Burns特效的幻灯片"></a>Hack8 附加Ken Burns特效的幻灯片</h3><p><em>问题：如何以幻灯片的形式展示多幅图片？</em></p><p>解决方案：该项目中循环播放图片，并利用 <strong>AnimatorSet.playTogether()</strong> 方法随机使用一种动画模式。</p><h3 id="Hack9-避免在EditText中验证日期"><a href="#Hack9-避免在EditText中验证日期" class="headerlink" title="Hack9 避免在EditText中验证日期"></a>Hack9 避免在EditText中验证日期</h3><p><em>问题：当用户需要在文本框里输入日期信息时，怎样设计才是最好的做法？</em></p><p>解决方案：开发者都知道验证表单里的日期数据是极其令人讨厌的事，因为不同用户输入的方式也大不一样。因此，开发者可以开发一个与EditText相同的Button（使用Button标签下的android:background=”@android:drawable/edit_text”语句），点击该按钮后，一个弹出的DatePickerDialog组件为用户提供日期选择服务。</p><p><strong>细心的读者可能会有这样的疑问：为什么不直接为EditText设置一个点击监听器，而非要使用Button呢？答案是：使用Button更安全，因为用户无法修改Button的文本内容。如果使用EditText，并且只设置了点击监听器，用户可以通过光标获取该控件的焦点，这样便可以绕过DatePicker控件直接修改EditText的文本内容。</strong></p><h3 id="Hack10-格式化TextView的文本"><a href="#Hack10-格式化TextView的文本" class="headerlink" title="Hack10 格式化TextView的文本"></a>Hack10 格式化TextView的文本</h3><p><em>问题：如何在TextView中添加不同样式的文本和链接？</em></p><p>解决方案：开发者可以使用 <strong>Html.fromHtml(String)</strong> 方法在TextView的文本内容中嵌入HTML代码，要注意的是嵌入HTML代码之后调用 <strong>TextView.setMovementMethod(LinkMovementMethod.getInstance())</strong> 将TextView设置为可点击状态。开发者还可以使用SpannableString类为字符串中的指定字符设置前景色与背景色。</p><p><strong>请注意：在XML文本中，像“&lt;”和“&amp;”字符都是非法的。因此，为了在XML中插入非法字符，开发者可以使用&lt;![CDATA[……]]&gt;语句，省略号处的语句允许使用“&lt;”和“&amp;”等字符。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;近来发现一本非常好的Android工具书——&lt;strong&gt;《50 Android Hacks》&lt;/strong&gt;，中文译名叫做 &lt;strong&gt;《Android开发必知的50个诀窍》&lt;/strong&gt;。与其他开发类书籍不同的是，该书并不是系统地讲解每一个知识点，而是以 &lt;strong&gt;问题/解决方案&lt;/strong&gt; 的形式提出开发过程中遇到的问题，并编写Demo程序给出合理的解决方案。本书适用于已经学习过Android开发的程序员，且每个项目对应的源代码都可以在&lt;a href=&quot;https://github.com/Macarse/50AH-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github 50AH-code&lt;/a&gt; 中下载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于笔者这种对Android开发有一定了解、希望学习到更好的解决方案的程序员来说，这本书非常受用。书中每一节内容对应一个Demo，简单粗暴地印证了 &lt;strong&gt;「Talk is cheap. Show me the code.」&lt;/strong&gt; 这句名言。在此，我将书中值得注意的地方整理出来，以免遗忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>Civilization and Barbarity</title>
    <link href="http://www.tingxiangshuixie.com/2017/08/23/civilization_and_barbarity/"/>
    <id>http://www.tingxiangshuixie.com/2017/08/23/civilization_and_barbarity/</id>
    <published>2017-08-23T17:30:00.000Z</published>
    <updated>2017-08-22T14:46:51.383Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=1066061&auto=0&height=66"></iframe><p>16年末的一个静谧的下午，我慵懒地睡了一个午觉后，毫无防备地听到了这首音乐，那一刻仿佛灵魂被什么东西击中。后来看了一些资料，得知此曲背后是一个关于印第安人的故事。</p><p>我想起了初中时候读过的阿瑟·柯南道尔一本书——<strong>《The Lost World》</strong>。也许很多人都以为 <strong>《福尔摩斯探案全集》</strong> 是柯南道尔的唯一作品，殊不知他的科幻小说同他的推理小说一样精彩。该书讲述了一支探险队到美洲某个高原探险，而这个高原上不仅有古老的 <strong>印第安部落</strong>，还生存着一些 <strong>史前生物</strong>（各种恐龙及其他已绝种生物）。</p><a id="more"></a><p>《The Lost World》最让人印象深刻的情节之一，是探险队发现了一片竹林，其中很多棵竹子上面有人的骨头。骨头并不是挂在枝杈上，而是紧紧地箍在主干上。探险队一行人谈论良久，仍没有搞清楚成因，直到后来他们被印第安部落发现。部落对外族人非常恐惧，对外族人的处罚是把他们从竹林上方的山崖顶推下去。因此才会有很多骨头挂在竹子上，实际上是像串肉串一样风干后形成的。</p><p>文学资料中大多用 <strong>野蛮</strong> 等字眼来形容这类部落或民族，而现代社会总是自诩为 <strong>文明</strong>。或许，古老的印第安部落族人也将自己称为 <strong>文明</strong>，而将外来入侵者归为 <strong>野蛮</strong>。</p><p><strong>那么，文明与野蛮究竟有怎样的差别？我想，这世上几乎没有绝对的文明与野蛮，大抵都是野蛮的文明与文明的野蛮吧。</strong></p><blockquote><p>苍茫天地间的古老民族<br>向生而死 向死而生<br>今人哀吟一曲 慷慨悲歌<br>也有音符无法承载的悲伤<br><br>我看到每个人心里都有个孩子<br>他们受了很重的伤<br>以至于 只有到了游乐场<br>孩子们才会出现<br><br>文明会诞生、会崛起、亦会消亡<br>世上一切终将归于 无<br>那一刻人们能做的<br>唯有歌唱</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;http://music.163.com/outchain/player?type=2&amp;id=1066061&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;16年末的一个静谧的下午，我慵懒地睡了一个午觉后，毫无防备地听到了这首音乐，那一刻仿佛灵魂被什么东西击中。后来看了一些资料，得知此曲背后是一个关于印第安人的故事。&lt;/p&gt;
&lt;p&gt;我想起了初中时候读过的阿瑟·柯南道尔一本书——&lt;strong&gt;《The Lost World》&lt;/strong&gt;。也许很多人都以为 &lt;strong&gt;《福尔摩斯探案全集》&lt;/strong&gt; 是柯南道尔的唯一作品，殊不知他的科幻小说同他的推理小说一样精彩。该书讲述了一支探险队到美洲某个高原探险，而这个高原上不仅有古老的 &lt;strong&gt;印第安部落&lt;/strong&gt;，还生存着一些 &lt;strong&gt;史前生物&lt;/strong&gt;（各种恐龙及其他已绝种生物）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="来者可追" scheme="http://www.tingxiangshuixie.com/tags/%E6%9D%A5%E8%80%85%E5%8F%AF%E8%BF%BD/"/>
    
  </entry>
  
  <entry>
    <title>Idea and Dream</title>
    <link href="http://www.tingxiangshuixie.com/2017/03/13/idea_and_dream/"/>
    <id>http://www.tingxiangshuixie.com/2017/03/13/idea_and_dream/</id>
    <published>2017-03-13T21:11:00.000Z</published>
    <updated>2017-04-18T07:28:53.800Z</updated>
    
    <content type="html"><![CDATA[<p>17年春节回家过年，遭遇了人生中一场不大不小的意外，住了半个月院，人也消沉了一个多月。朋友开玩笑说“事业刚起步就摔了个大跟头”，可不是，当真是 <strong>摔了个大跟头</strong> ，而且是 <strong>爬起来也走不了路</strong> 那种。</p><p>也许是冥冥中上苍给了我一个放松身心、休养生息的机会，可以放慢脚步、静下心来做一做诸多想做的抑或是未完成的事，可自己却一直也没打起精神。颓唐的时候看了许多影视、文字作品，庆幸无一不是佳作。而后感悟颇多，在这样一个月色很好的凉夜里，写下这篇关于 <strong>想法与梦想</strong> 的思考。</p><a id="more"></a><p>我是一个想象力蛮丰富的人，看到任何东西都会想着如果是我会怎么去设计。打个比方，我曾设想过 <strong>水果捞式朝鲜冷面</strong> 、 <strong>西红柿炒鸡蛋馅儿的水饺</strong> 或是 <strong>把菠萝做成细碎的果肉揉到白面里蒸馒头</strong> ……对任何事都有兴趣去了解，但失去兴趣也非常快，缺乏行动力。谈到这儿，我想说说前阵子领导要我们每个人设计一款新产品的事儿。我提出来的是一个大约两年以前的想法，写给领导的报告如下。</p><h3 id="一个关于移动应用的微不足道的小想法——公益生活（每个人都可以为公益社会尽一份力）"><a href="#一个关于移动应用的微不足道的小想法——公益生活（每个人都可以为公益社会尽一份力）" class="headerlink" title="一个关于移动应用的微不足道的小想法——公益生活（每个人都可以为公益社会尽一份力）"></a>一个关于移动应用的微不足道的小想法——公益生活（每个人都可以为公益社会尽一份力）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">现如今随着全民综合素质的提高和移动互联网的飞速发展，越来越多的公益性的功能加入到了各种各样的APP中。以中国排名数一数二的互联网公司为例，腾讯旗下的微信在很早以前就有公益募捐、众筹等功能，而阿里巴巴旗下的支付宝包含丢失孩子的信息提示或是节能减排可兑换能量进而兑换真实的树苗进行植树造林的功能（蚂蚁森林）。形形色色的公益虽多，但做公益还有很长的路要走。xxx作为国家主办的综合新闻信息服务门户网站，作为全球网民了解中国的最重要窗口，更有义务当仁不让，为公益事业添砖加瓦。</span><br><span class="line">我关于公益性APP的设计有一下几点想法：失物招领以及走失老人、儿童的信息发布。互联网上不乏有相似的功能的网站，比如公安局失物招领系统、高校校内论坛等等，但要么是使用范围极小，要么是用户过少。有诉求的人们不知道该去哪儿发布消息，没有诉求的人们也不知道自己的举手之劳就可能帮别人很大的忙。因此，一个公益性的APP是相当大的用武之地的。下面来谈谈这个想法的实现过程中需要解决的几个问题。</span><br><span class="line">1.技术难度</span><br><span class="line">失物招领可以通过街道（或区域）索引完成，在用户量比较大的情况下服务器消耗比较大，还有可能会用到地图资源，可能需要其他公司的技术支持。另外为了争取到最大的用户量，只有手机客户端是一定不够的，一定要有网页端，需要前端、服务端支持或外包团队支持。</span><br><span class="line">2.运营难度</span><br><span class="line">一个公益性的东西想要推行是非常非常困难的，如果用户没有觉得从这个APP里得到什么，这个APP又不是刚需，那么想完全靠国民素质来支持该产品的使用量就是天方夜谭。除了依靠专业运营团队的帮助外，我想说的一点是——奖励机制。我们可以利用现有的资源，为所有做了好事的人按照其贡献提供一定的奖励。小奖励比如一些虚拟货币、代金券等等，大奖励比如我们可以给做出巨大贡献的人颁发一些证书、锦旗等等。随着用户不断地增加，产品也不断地获得认可，颁发的证书、锦旗无形之中也会获得社会性的认可（比如可以写在个人履历或简历中），而这反过来又刺激了用户去做更多的好事……这是一个不断滚雪球的正反馈过程。</span><br><span class="line">3.盈利难度</span><br><span class="line">想从公益产品中盈利很难，但并非不可能。首先可以建立打赏机制，如果失主通过平台找到了丢失的东西即可给平台及帮助失主的人打赏。在平台具有一定规模的时候，赞助商自然也就不请自来了。而且，我们还可以得到一些公益基金的支持。</span><br><span class="line">最后我想说，想做公益，任何时候下定决心都不算太晚，任何时候轻言放弃都为时尚早。</span><br></pre></td></tr></table></figure><p>结果不出所料，所有想法随着一个新项目的到来不了了之。但很快博主得到一个特别有趣的消息，被领导视作最大竞争对手的今日头条公司，已经把一款相似的公益项目做成功一年有余了。</p><p><img src="/assets/blogImg/bytedancer.png" alt="今日头条的公益项目"></p><p>而就在几个月之后，一款名为 <strong>朝阳群众</strong> 的App风靡了北京城的大街小巷。</p><p><img src="/assets/blogImg/chaoyangqunzhong_1.jpg" alt="App Store上架"></p><p><img src="/assets/blogImg/chaoyangqunzhong_2.jpg" alt="朝阳群众App首页"></p><p><img src="/assets/blogImg/chaoyangqunzhong_3.jpg" alt="朝阳群众App主体功能"></p><p><img src="/assets/blogImg/chaoyangqunzhong_4.jpg" alt="朝阳群众App警民联动"></p><p>看着自己的想法一步步被别人实现并越做越大，心中悲喜交加。悲之无能为力，心有不甘；喜之想法可行，且有同行为公益事业献出微薄之力。多么希望自己也能参与到其中，而不是以 <strong>多走路</strong> 、 <strong>多支付</strong> 这样的鸡肋行动来满足自己碌碌无为的公益心。</p><p><img src="/assets/blogImg/tree.png" alt="蚂蚁森林"></p><p>在医院的病床上读完了《牧羊少年的奇幻之旅》，感触颇多。这本书一直强调一个词——【<strong>天命</strong>】，还有一句最为著名的话—— <strong>当你无比渴望得到某些东西时，整个宇宙都会协力使你实现自己的愿望</strong> 。书中每个人物都曾梦到过一些事，也就是各自的天命，有些人毅然决然选择去追寻，而有些人选择了妥协或遗忘。</p><p>童话故事往往比现实生活多了一些奇妙元素。若在现实生活中有极好的运气，会梦到一些意想不到的思路，但是却永远没办法像童话一样梦见自己的梦想。有些人说，有了梦想活得很累，因为要不断地追求。殊不知没有梦想活得更累，焦虑始终困扰着你，无法平息。 </p><p><strong>愿你梦中所想，即是梦想</strong> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17年春节回家过年，遭遇了人生中一场不大不小的意外，住了半个月院，人也消沉了一个多月。朋友开玩笑说“事业刚起步就摔了个大跟头”，可不是，当真是 &lt;strong&gt;摔了个大跟头&lt;/strong&gt; ，而且是 &lt;strong&gt;爬起来也走不了路&lt;/strong&gt; 那种。&lt;/p&gt;
&lt;p&gt;也许是冥冥中上苍给了我一个放松身心、休养生息的机会，可以放慢脚步、静下心来做一做诸多想做的抑或是未完成的事，可自己却一直也没打起精神。颓唐的时候看了许多影视、文字作品，庆幸无一不是佳作。而后感悟颇多，在这样一个月色很好的凉夜里，写下这篇关于 &lt;strong&gt;想法与梦想&lt;/strong&gt; 的思考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="来者可追" scheme="http://www.tingxiangshuixie.com/tags/%E6%9D%A5%E8%80%85%E5%8F%AF%E8%BF%BD/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊适合成年人玩的智力玩具</title>
    <link href="http://www.tingxiangshuixie.com/2017/01/04/puzzle/"/>
    <id>http://www.tingxiangshuixie.com/2017/01/04/puzzle/</id>
    <published>2017-01-04T20:30:00.000Z</published>
    <updated>2017-01-04T14:03:00.996Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/blogImg/puzzle_1.jpg" alt="Boys never grow up"></p><blockquote><p>每个男人心中都有一个小男孩，对于玩具的热爱，只是他们对于童年心中遗憾的弥补。</p></blockquote><h3 id="魔方"><a href="#魔方" class="headerlink" title="魔方"></a>魔方</h3><p><strong>魔方</strong> 与 <strong>华容道</strong>、<strong>独立钻石棋</strong> 一起被国外智力专家并称为 <strong>智力游戏界的三个不可思议</strong>。魔方最早是由匈牙利布达佩斯建筑学院厄尔诺·鲁比克教授在1974年发明的，最早的魔方为三阶魔方。</p><p>随着魔方风靡全球，越来越多其他类型的魔方被发明出来，如二阶到二十二阶、镜面魔方、SQ1魔方、金字塔魔方、斜转魔方、五魔方、球形魔方、齿轮魔方等等。</p><a id="more"></a><p><img src="/assets/blogImg/puzzle_2.jpg" alt="高阶魔方"></p><p><img src="/assets/blogImg/puzzle_3.jpg" alt="镜面魔方"></p><p><img src="/assets/blogImg/puzzle_4.jpg" alt="SQ1魔方"></p><p><img src="/assets/blogImg/puzzle_5.jpg" alt="金字塔魔方"></p><p><img src="/assets/blogImg/puzzle_6.jpg" alt="斜转魔方"></p><p><img src="/assets/blogImg/puzzle_7.jpg" alt="五魔方"></p><p><img src="/assets/blogImg/puzzle_8.jpg" alt="球形魔方"></p><p><img src="/assets/blogImg/puzzle_9.jpg" alt="齿轮魔方"></p><h3 id="华容道"><a href="#华容道" class="headerlink" title="华容道"></a>华容道</h3><p>华容道是古老的中国民间益智游戏，属于 <strong>滑块类游戏</strong>，就是在一定范围内，按照一定条件移动一些称作 <strong>块</strong> 的东西，最后满足一定的要求。</p><p>经证明，华容道标准开局的最快解法为 <strong>81</strong> 步。</p><p><img src="/assets/blogImg/puzzle_10.jpg" alt="华容道"></p><h3 id="独立钻石棋"><a href="#独立钻石棋" class="headerlink" title="独立钻石棋"></a>独立钻石棋</h3><p>独立钻石棋，又称 <strong>单身贵族棋</strong>，源于18世纪法国的宫廷贵族的自我挑战类单人棋游戏，可以锻炼逻辑思维能力。游戏玩法似中国跳棋，但不能走步，只能跳。棋子只能跳过相邻的棋子到空位上，并且把被跳过的棋子吃掉。棋子可以沿格线横、纵方向跳，但是不能斜跳，剩下越少棋子越好。</p><p>游戏级别：最后剩下 <strong>6只或以上</strong> 棋子是 <strong>一般</strong>；剩下 <strong>5只</strong> 棋子是 <strong>颇好</strong>；剩下 <strong>4只</strong> 棋子是 <strong>很好</strong>；剩下 <strong>3只</strong> 棋子是 <strong>聪明</strong>；剩下 <strong>2只</strong> 棋子是 <strong>尖子</strong>；剩下 <strong>1只</strong> 棋子是 <strong>大师</strong>；最后剩下 <strong>1只</strong>，而且在 <strong>正中央</strong> 是 <strong>天才</strong>。</p><p><img src="/assets/blogImg/puzzle_11.jpg" alt="独立钻石棋"></p><h3 id="巧环"><a href="#巧环" class="headerlink" title="巧环"></a>巧环</h3><p>巧环是依据数学的 <strong>拓扑原理</strong>，由梁、环、柄、绳、珠等结构元素组合而成的智力玩具，一般用金属、木头、绳索、玉石等材质制作。它是我国富有民族特色的一种智力游戏，亦是中国民间古典智力玩具的精粹。</p><p>巧环中最为著名的当属 <strong>九连环</strong>。九连环是中国传统民间智力玩具。以金属丝制成9个圆环，将圆环套装在横板或各式框架上，并贯以环柄。把玩时，按照一定的程序反复操作，可使9个圆环与柄分开，或合二为一。</p><p><img src="/assets/blogImg/puzzle_12.jpg" alt="九连环"></p><p><img src="/assets/blogImg/puzzle_13.jpg" alt="其他巧环"></p><h3 id="孔明锁"><a href="#孔明锁" class="headerlink" title="孔明锁"></a>孔明锁</h3><p>孔明锁，相传是三国时期诸葛孔明根据八卦玄学的原理发明的一种玩具，曾广泛流传于民间。逐渐得到人们的重视，它对放松身心，开发大脑，灵活手指均有好处。它是老少皆宜的休闲玩具。孔明锁看上去简单，其实内中奥妙无穷，不得要领，很难完成拼合。</p><p>这只是传说之一。另外一种传说是：传说春秋时代鲁国工匠鲁班为了测试儿子是否聪明，用6根木条制作一件可拼可拆的玩具，叫儿子拆开。儿子忙碌了一夜，终于拆开了。这种玩具后人就称作鲁班锁．其实这只是一种传说．它起源于中国古代建筑中首创的 <strong>榫卯</strong> 结构。</p><p>所以，孔明锁亦称 <strong>鲁班锁</strong> 、<strong>别闷棍</strong> 、<strong>六子联方</strong> 、<strong>莫奈何</strong> 、<strong>难人木</strong>等。</p><p><img src="/assets/blogImg/puzzle_14.jpg" alt="孔明锁"></p><h3 id="魔金"><a href="#魔金" class="headerlink" title="魔金"></a>魔金</h3><p>魔金，又称 <strong>Cast Puzzle</strong>，起源于19世纪英国，发展于20世纪日本，21世纪来到中国。规则很简单，把金属部分分开，再重新组合。其拥有散发着神秘感的巧妙造型和变化多端的奇妙结构常常会给玩家带了奇妙的乐趣，当然也可能百般尝试仍毫无进展。</p><p><img src="/assets/blogImg/puzzle_15.jpg" alt="魔金图鉴"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/blogImg/puzzle_1.jpg&quot; alt=&quot;Boys never grow up&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个男人心中都有一个小男孩，对于玩具的热爱，只是他们对于童年心中遗憾的弥补。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;魔方&quot;&gt;&lt;a href=&quot;#魔方&quot; class=&quot;headerlink&quot; title=&quot;魔方&quot;&gt;&lt;/a&gt;魔方&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;魔方&lt;/strong&gt; 与 &lt;strong&gt;华容道&lt;/strong&gt;、&lt;strong&gt;独立钻石棋&lt;/strong&gt; 一起被国外智力专家并称为 &lt;strong&gt;智力游戏界的三个不可思议&lt;/strong&gt;。魔方最早是由匈牙利布达佩斯建筑学院厄尔诺·鲁比克教授在1974年发明的，最早的魔方为三阶魔方。&lt;/p&gt;
&lt;p&gt;随着魔方风靡全球，越来越多其他类型的魔方被发明出来，如二阶到二十二阶、镜面魔方、SQ1魔方、金字塔魔方、斜转魔方、五魔方、球形魔方、齿轮魔方等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="思者无惑" scheme="http://www.tingxiangshuixie.com/tags/%E6%80%9D%E8%80%85%E6%97%A0%E6%83%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.tingxiangshuixie.com/2016/12/27/hello_world/"/>
    <id>http://www.tingxiangshuixie.com/2016/12/27/hello_world/</id>
    <published>2016-12-27T14:58:00.000Z</published>
    <updated>2016-12-27T15:23:25.141Z</updated>
    
    <content type="html"><![CDATA[<p>特别遗憾自己在大学的时候没有写博客的觉悟，如果从那个时候就坚持去记录一些东西的话，无论内容如何，积累到如今总归会有一个令人惊讶的数值的。这世上有太多的事逝去后才追悔莫及，所谓 <strong>往者不可谏</strong>。但是往往愈令人后悔的事，愈给人以深刻的教训，所谓 <strong>往者可鉴</strong>。</p><p>值得庆幸的是 <strong>来者犹可追</strong>。在大学毕业后在CSDN上写了几篇博客，编辑器排版不好用是一方面，每次修改文章都要经过审核实在是不方便。终于在一些前辈们的刺激下，萌生了注册个人域名搭博客的想法。</p><a id="more"></a><p>折腾了两三天的时间，从购买域名到利用 <strong>Hexo</strong> 和 <strong>Github Pages</strong> 搭建再到主题的选择及替换，每完成一步都收获一份喜悦。几乎所有的英文单词域名都早已被注册过了，索性我选择拼音 <strong>听香水榭</strong> 作为域名，竟然成功了。那种心情一时间很难形容，我仿佛打开了封闭已久的屋子的一扇窗户，可以向世界发出自己的声音而不是通过别人带话了。</p><p>感谢前辈们的辛勤努力，感谢开源社区。</p><p>这是 <strong>我的地盘</strong>，<strong>我做主</strong>。这里没有广告，没有言论限制，没有操作频率限制。博主不会写软文，也不会写心灵鸡汤。这里共有4个版块：</p><ul><li><strong>往者可鉴</strong>（工作及平时学习的技术分享）</li><li><strong>来者可追</strong>（生活琐记）</li><li><strong>思者无惑</strong>（博主搜集到的智玩的介绍及解法）</li><li><strong>行者无疆</strong>（游记）</li></ul><p>无论到此的是亲朋好友还是天涯过客，我都要对你说一句——<strong>见到你很高兴</strong>。</p><p>最后以我曾写的三行情诗作为结尾：</p><blockquote><p>初次遇见你<br>让我想起了人类的第一个程序<br>hello, world</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特别遗憾自己在大学的时候没有写博客的觉悟，如果从那个时候就坚持去记录一些东西的话，无论内容如何，积累到如今总归会有一个令人惊讶的数值的。这世上有太多的事逝去后才追悔莫及，所谓 &lt;strong&gt;往者不可谏&lt;/strong&gt;。但是往往愈令人后悔的事，愈给人以深刻的教训，所谓 &lt;strong&gt;往者可鉴&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;值得庆幸的是 &lt;strong&gt;来者犹可追&lt;/strong&gt;。在大学毕业后在CSDN上写了几篇博客，编辑器排版不好用是一方面，每次修改文章都要经过审核实在是不方便。终于在一些前辈们的刺激下，萌生了注册个人域名搭博客的想法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="来者可追" scheme="http://www.tingxiangshuixie.com/tags/%E6%9D%A5%E8%80%85%E5%8F%AF%E8%BF%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之版本更新及自定义通知详解</title>
    <link href="http://www.tingxiangshuixie.com/2016/12/11/android_download_and_notification/"/>
    <id>http://www.tingxiangshuixie.com/2016/12/11/android_download_and_notification/</id>
    <published>2016-12-11T17:30:00.000Z</published>
    <updated>2017-09-26T13:39:59.526Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我现在真的羡慕iOS开发程序员，他们既不用考虑应用升级，更不用处理机型适配这些令人头疼而无意义的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——题记</p></blockquote><p>本文将从以下几个方面详解Android开发版本更新及自定义通知的那些坑。</p><ul><li><strong>Service下载文件要注意的小细节</strong></li><li><strong>Android高版本通知图标无法显示（出现白框）</strong></li><li><strong>通知图标只能显示中间的一部分，无法显示完整</strong></li><li><strong>高版本通知提示无法在状态栏中显示</strong></li><li><strong>自定义通知文字颜色适配</strong></li></ul><a id="more"></a><h3 id="Service下载文件要注意的小细节"><a href="#Service下载文件要注意的小细节" class="headerlink" title="Service下载文件要注意的小细节"></a>Service下载文件要注意的小细节</h3><p>国内Android应用市场繁杂，几乎没人使用Google Play下载和升级软件。所以，应用程序升级变成了每个APP开发者的任务。Android系统下载文件一般有三种方式：<strong>Activity中开启一个线程下载</strong>、<strong>利用系统DownloadManager下载</strong> 和 <strong>使用Service在后台下载</strong>。第一种方式下载时Activity无法关闭，使用起来非常不方便；系统提供的DownloadManager比较好用，开发者几乎不用考虑任何事情只需要提供下载链接就可以，但是DownloadManager的外观及细节实在做的太差。因此，大多数Android产品使用第三种下载方式——Service。</p><p>笔者在Service的 <strong>onHandleIntent()</strong> 方法中接收到MainActivity传入的下载链接，并使用 <strong>HttpURLConnection</strong> 进行文件下载，业务流程非常简单，此处不再赘述。</p><p><strong>一个小细节：在MainActivity中应判断下载文件的Service是否运行，如果已经在下载则提示版本更新弹窗，一方面提高用户体验，另一方面防止Service被多次开启引发程序异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWorked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityManager myManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    ArrayList&lt;ActivityManager.RunningServiceInfo&gt; runningService = (ArrayList&lt;ActivityManager.RunningServiceInfo&gt;) myManager.getRunningServices(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; runningService.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runningService.get(i).service.getClassName().equals(<span class="string">"your package.DownloadService"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义Notification"><a href="#自定义Notification" class="headerlink" title="自定义Notification"></a>自定义Notification</h3><p>使用了Service下载，为了不影响用户操作就不应该使用Activity或是Dialog等更新下载进度，那么我使用在 <strong>Notification</strong> 加入 <strong>ProgressBar</strong> 来更新下载进度并通知用户是否更新。而为了显示更全面的信息，如下载进度、当前下载速度等等，我选择使用自定义Notification来完成。（由于产品设计APP主要以iOS系统为参照，安卓版本更新部分并没有任何涉猎，于是这部分功能全权交给我去设计完成，我便走上了一条自己给自己挖坑的 <strong><em>不归路</em></strong>。）</p><p>笔者设计的通知布局如下：左侧显示应用程序的图标；右侧上部显示“xx程序正在下载”，下载结束后显示“下载完成，请点击安装”；后侧中部显示进度条；<br>右侧下部包含两个文本框，分别显示当前下载速度和当前下载进度百分比。</p><p><img src="/assets/blogImg/android_download&amp;notification_1.png" alt="自定义Notification布局"></p><h3 id="Android高版本通知图标无法显示（出现白框）"><a href="#Android高版本通知图标无法显示（出现白框）" class="headerlink" title="Android高版本通知图标无法显示（出现白框）"></a>Android高版本通知图标无法显示（出现白框）</h3><p>做好这一切后，笔者迫不及待地在测试机跑了一遍程序，遇到了自定义Notification的第一个坑——在Android 5.0版本以前通知可以正常显示，但5.0及以后的版本状态栏中只能显示出一个白色方框，如下图所示：</p><p><img src="/assets/blogImg/android_download&amp;notification_2.png" alt="Notification图标白框bug"></p><p>究其原因，是Android系统开发者为了统一UI样式，限定在Android 5.0版本之后，状态栏显示的图标必须只能是 <strong>白色</strong> 的。这显然为难不了我，甚至不需要跟产品和美工提需求，自己三下五除二用PS抠好了图。</p><p><img src="/assets/blogImg/android_download&amp;notification_3.png" alt="白色图标"></p><p>在构造Notification的时候判断版本，<strong>SDK低于21</strong> 选用 <strong>彩色图标</strong>，<strong>大于等于21</strong> 选用 <strong>纯白色图标</strong>，最终结果如下：</p><p><img src="/assets/blogImg/android_download&amp;notification_4.png" alt="白色Notification图标"></p><h3 id="通知图标只能显示中间的一部分，无法显示完整"><a href="#通知图标只能显示中间的一部分，无法显示完整" class="headerlink" title="通知图标只能显示中间的一部分，无法显示完整"></a>通知图标只能显示中间的一部分，无法显示完整</h3><p>如果直接把程序图标（ic_launcher）设置为Notification的SmallIcon，某些机型出现的问题是状态栏只能显示图标的中间一部分，无法显示完整。</p><p>原因是原图标（144* 144）过大，将其 <strong>重命名</strong> 并改为 <strong>48* 48</strong> 并放在 <strong>xhdpi</strong> 即可显示正常。这个问题在网上很普遍并且较易解决，在此不予演示。</p><h3 id="高版本通知提示无法在状态栏中显示"><a href="#高版本通知提示无法在状态栏中显示" class="headerlink" title="高版本通知提示无法在状态栏中显示"></a>高版本通知提示无法在状态栏中显示</h3><p>通知时提示的文字在Android 5.0之后不显示了。跟上述图标白框问题相似，Android系统开发者在5.0之后 <strong>禁用状态栏显示文字</strong>（setTicker()方法），相仿iOS系统在手机上部出现 <strong>通知弹窗</strong> 。因此，需要在构造通知时判断版本，<strong>SDK低于21</strong> 使用 <strong>setTicker()</strong> 方法，<strong>大于等于21</strong> 使用 <strong>setFullScreenIntent()</strong> 方法，最终结果如下：</p><p><img src="/assets/blogImg/android_download&amp;notification_5.png" alt="高版本弹窗通知"></p><h3 id="自定义通知文字颜色适配"><a href="#自定义通知文字颜色适配" class="headerlink" title="自定义通知文字颜色适配"></a>自定义通知文字颜色适配</h3><p>最后一个坑也是最让人头疼的坑，则是不同的Android手机的自定义Notification的文字颜色适配。市场上流通的Android手机有无数种样式的通知栏，如果指定了文字颜色会出现与特殊机型的背景颜色相近而影响美观的问题。而这个问题一般有两种解决方式：</p><ol><li><strong>干脆连同通知背景颜色也指定，保证黑底白字或白底黑字，不考虑通知栏的背景颜色。</strong></li><li><strong>获取到当前系统通知栏及通知的颜色数据，根据不同版本做适配。</strong></li></ol><p>第一种解决方式显然并不完美，很容易在某些机型出现“极其违和”的通知样式，对于一个完美主义者来说这是无法容忍的，于是我义无反顾地选择了第二种解决方式。</p><p>为了给用户带来较好的使用感受，将自定义Notification的布局北京设置为 <strong>透明</strong>，这样无论图片文字还是进度条看起来都是“嵌入到通知栏背景”中。在Android 5.0版本前， 通知栏的背景以黑色（灰色）为主，而在其之后通知栏以白色为主。笔者灵机一动，不指定TextView的文字颜色，是否就是系统默认的颜色呢？经测试此方法在低版本机型成功率较高，高版本普遍出现了问题。因为TextView的背景颜色并不等同于通知栏的背景颜色，所以文字颜色（可以理解为背景颜色的相反颜色，即对比色）也并不一定相近。</p><p>第一种方式失败之后，笔者查阅资料，有另外一种解决方式是我们可以先构造一个Notification（并不发出通知）并获取其中title的 <strong>颜色</strong>，这样我们可以在自定义Notification沿用 <strong>该颜色</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNotificationColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NotificationCompat.Builder builder = (NotificationCompat.Builder) <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);</span><br><span class="line">    Notification notification = builder.build();</span><br><span class="line">    ViewGroup viewGroup = (ViewGroup) notification.contentView.apply(<span class="keyword">this</span>, <span class="keyword">new</span> LinearLayout(<span class="keyword">this</span>));</span><br><span class="line">    TextView title = (TextView) viewGroup.findViewById(android.R.id.title);</span><br><span class="line">    <span class="keyword">return</span> title.getCurrentTextColor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在高版本机型依旧出现 <strong>空指针异常</strong> 的问题， <strong>Notification.contentView</strong> 为空，具体原因笔者没有深入研究，大概是低版本系统Notification也像是自定义Notification一样使用了 <strong>系统提供</strong> 的 <strong>RemoteViews</strong>，而高版本已经不再使用这种方式构造通知。</p><p>最终笔者选择的解决方式是设置TextView中的 <strong>textAppearance属性</strong>，<strong>SDK低于21</strong> 使用 <strong>android:TextAppearance.StatusBar.EventContent.Title</strong> 样式，<strong>大于等于21</strong> 使用 <strong>android:TextAppearance.Material.Notification.Title</strong> 样式，几乎能适配大部分系统。但仍有一部分手机开发者改变了原生Notification的背景，比如笔者的一款测试机——三星S5，<strong>黑色半透明通知栏+白色通知背景+黑色文字</strong>。</p><p><img src="/assets/blogImg/android_download&amp;notification_6.png" alt="三星特殊通知栏样式"></p><p>这样使用的 <strong>文字颜色</strong>（黑色）直接放在 <strong>通知栏</strong> 处（黑色）非常冲突，而这个问题笔者想了好久，尝试获取到通知栏背景色从根本上解决这一问题，但似乎官方并没有给出任何方法。何况很多手机更改了系统状态栏，背景颜色并不是一个值，而是有不同颜色的一幅图片，想去获取颜色恐怕只能用Bitmap去解析几个点的 <strong>ARGB</strong> 值了。</p><p><img src="/assets/blogImg/android_download&amp;notification_7.png" alt="其他特殊的通知栏样式"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望Google官方以及各个手机厂商的开发者们能够在追求UI与众不同的时候，考虑一下其他Android开发者们做适配的难处，能够提供出通知栏的背景颜色（哪怕给出是深色还是浅色）就再好不过了。如果读到这篇文章的你恰巧知道获取通知栏背景颜色的方法，麻烦能分享给我，笔者不胜感激。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我现在真的羡慕iOS开发程序员，他们既不用考虑应用升级，更不用处理机型适配这些令人头疼而无意义的问题。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;——题记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文将从以下几个方面详解Android开发版本更新及自定义通知的那些坑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Service下载文件要注意的小细节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Android高版本通知图标无法显示（出现白框）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通知图标只能显示中间的一部分，无法显示完整&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高版本通知提示无法在状态栏中显示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义通知文字颜色适配&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之启动页的作用</title>
    <link href="http://www.tingxiangshuixie.com/2016/11/16/android_startup/"/>
    <id>http://www.tingxiangshuixie.com/2016/11/16/android_startup/</id>
    <published>2016-11-16T13:30:00.000Z</published>
    <updated>2017-01-03T06:01:47.025Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇文章所描述的登录功能逻辑并不复杂，与之相比登出功能更是特别简单，只需要跳转到登录Activity即可。值得注意的是，当用户登出后，需要将登出页的Activity以及之前的诸多Activity <strong>全部清除</strong>，避免用户使用 <strong>后退</strong> 返回到前面打开过的Activity中。</p><h3 id="应用程序启动页的设计"><a href="#应用程序启动页的设计" class="headerlink" title="应用程序启动页的设计"></a>应用程序启动页的设计</h3><p>为什么APP要有启动页？启动页有什么作用？ <strong>启动页并不是为APP提供机会进行艺术展示，而是为了增强用户对应用程序能够快速启动并立即投入使用的感知度</strong>。实际上启动页相当于一个进度条的作用，APP需要在这个过程中完成 <strong>是否登录的验证</strong>、<strong>有无新版本待升级的验证</strong> 甚至 <strong>某些大型资源的加载</strong> 等等，待所有工作执行完毕，启动页跳转到下一个页面，给用户一个流畅的交互体验。</p><a id="more"></a><p>通常启动页只有一张带有LOGO的全屏图片，需要设置 <strong>android:background</strong>  为你的图片资源并将MainActivity的 <strong>theme设置为@android:style/Theme.NoTitleBar.FullScreen</strong>。启动页的内部逻辑，通常会判断用户的登录状态。在用户 <strong>第一次登陆成功</strong>之后，服务器会 <strong>根据用户的ID及登录时间生成一个token字符串并返回给客户端</strong>，客户端开发者需要将 <strong>token保存到SharedPreferences</strong> 中，在每次应用开启的时候验证token是否正确或过期，进而判断跳转到登录页或是主菜单页中。</p><p>笔者所开发APP还要在启动页判断 <strong>是否存在新版本并提醒用户升级</strong>，这就需要在向服务器请求后服务器返回的json数据中包含 <strong>最新版应用的版本号</strong> 及 <strong>下载地址</strong>。这地方出现了一个小插曲：客户端启动并发出请求，登录状态及版本信息可以压缩到一组json数据中，所以为了提高效率要尽可能 <strong>降低联网请求行为次数</strong>。后台在token正确的时候返回的数据很正常，可是在token不存在或不正确的情况下直接返回了 <strong>404</strong>，获取不到版本信息，我特地跟后端沟通之后重新定制了接口返回值后才解决了这个问题。</p><p>程序开发过程中，客户端与服务端要多商量细节的设计，避免产生不必要的麻烦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一篇文章所描述的登录功能逻辑并不复杂，与之相比登出功能更是特别简单，只需要跳转到登录Activity即可。值得注意的是，当用户登出后，需要将登出页的Activity以及之前的诸多Activity &lt;strong&gt;全部清除&lt;/strong&gt;，避免用户使用 &lt;strong&gt;后退&lt;/strong&gt; 返回到前面打开过的Activity中。&lt;/p&gt;
&lt;h3 id=&quot;应用程序启动页的设计&quot;&gt;&lt;a href=&quot;#应用程序启动页的设计&quot; class=&quot;headerlink&quot; title=&quot;应用程序启动页的设计&quot;&gt;&lt;/a&gt;应用程序启动页的设计&lt;/h3&gt;&lt;p&gt;为什么APP要有启动页？启动页有什么作用？ &lt;strong&gt;启动页并不是为APP提供机会进行艺术展示，而是为了增强用户对应用程序能够快速启动并立即投入使用的感知度&lt;/strong&gt;。实际上启动页相当于一个进度条的作用，APP需要在这个过程中完成 &lt;strong&gt;是否登录的验证&lt;/strong&gt;、&lt;strong&gt;有无新版本待升级的验证&lt;/strong&gt; 甚至 &lt;strong&gt;某些大型资源的加载&lt;/strong&gt; 等等，待所有工作执行完毕，启动页跳转到下一个页面，给用户一个流畅的交互体验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>Android开发之登录功能细节记录</title>
    <link href="http://www.tingxiangshuixie.com/2016/11/14/android_login/"/>
    <id>http://www.tingxiangshuixie.com/2016/11/14/android_login/</id>
    <published>2016-11-14T12:30:00.000Z</published>
    <updated>2017-10-10T15:03:31.693Z</updated>
    
    <content type="html"><![CDATA[<p>博主作为一名Android开发新人参与的第一个项目，是开发一个直播软件，我负责信息验证、登录以及设置等功能的实现。坦白讲功能逻辑很简单，如果做Demo大概不过一天工夫。但如果要做得很漂亮，给用户一种非常好的使用体验，一些细节还真的需要仔细琢磨。下面我将分享一下在开发登录功能时遇到的一些值得记录的东西。</p><p>通常来说登录页面包含两个 <strong>EditText</strong>，分别对应使用者的账号密码（手机端验证码出现比较少，暂不考虑），不妨先来说说一款优秀的手机应用登录页面应该包含哪些人性化的小组件。</p><a id="more"></a><h3 id="功能组件的设置"><a href="#功能组件的设置" class="headerlink" title="功能组件的设置"></a>功能组件的设置</h3><p>1.很多应用的EditText为了给用户一个非常好的 <strong>交互感受</strong>，会在 <strong>左端</strong> 设计一个表示输入内容的 <strong>小图标</strong>。如“账号”出设置一个人头像，“密码”处设置一把锁头或钥匙，“搜索”处设置一个放大镜等等。这个时候要用到以下几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android:drawableLeft     <span class="comment">//设置位于EditText左边的小图标  </span></span><br><span class="line">android:paddingLeft      <span class="comment">//设置该图标距离EditText左端的距离  </span></span><br><span class="line">android:drawablePadding  <span class="comment">//设置hint或输入的文本与左边小图标的距离  </span></span><br><span class="line">android:hint             <span class="comment">//设置EditText在没有任何输入的时候显示的提示，设置后利于自定义下划线</span></span><br></pre></td></tr></table></figure><p>2.由于Android <strong>原生EditText</strong> 的下划线视觉体验非常一般，很多UI设计师选择设计其他样式或者颜色的下划线，这时候就需要 <strong>取消</strong> 原生EditText下划线的显示，而使用 <strong>ImageView</strong> 画一条下划线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:background=<span class="string">"@null"</span> <span class="comment">//取消原生EditText下划线的显示</span></span><br></pre></td></tr></table></figure><p>3.一个用户体验较好的EditText，还应该在输入框右端设置一个 <strong>×</strong> 图标，用于一键清空输入的文本信息。实现的方法类似于上述设置左端小图标，还需要补充的是在登录的Activity类中为 <strong>ImageView</strong> 设置 <strong>onclick()</strong> 方法，在方法中加入 <strong>EditText.setText(“”);</strong> 即可。</p><p>4.在登录Activity中，最好包含 <strong>记住账号密码</strong> 功能，为了操作简便笔者在登录成功后直接将账号和密码写入到 <strong>SharedPreferences</strong> 中，在 <strong>onCreate()</strong> 方法中读取账号密码并将二者 <strong>回显到EditText</strong> 中（因为是公司内部用的软件所以只考虑每部手机绑定一个账号，没有使用下拉列表）。如果要绑定多个账号密码请选择使用带下拉框的EditText进行回显。</p><h3 id="值得深究的细节"><a href="#值得深究的细节" class="headerlink" title="值得深究的细节"></a>值得深究的细节</h3><p>以上是登录页面的常规功能的实现，下面来说说开发登录功能时应该注意的小细节：</p><ol><li>将EditText的 <strong>maxLines属性设为1</strong>。程序员们编程普遍的思想是先思考 <strong>我在使用这个APP的时候会做哪些事？</strong>，然后将这些事情解决就好了。但是产品经理或测试思考的是 <strong>一个傻瓜在使用这个APP的时候会做哪些事？</strong>，这就非常需要我们程序员们做好限制了。虽说一般不会有人的账号密码足够长到第二行去，也不会输入到一半莫名其妙按回车键，但如果真的有这种情况出现导致布局变形或是程序崩溃，最终需要负责任的仍然是我们程序员。</li><li>在EditText中 <strong>禁用回车键</strong>。原因同上，但实现起来却出现了一些状况。代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEditorAction</span><span class="params">(TextView v, <span class="keyword">int</span> actionId, KeyEvent event)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">switch</span> (v.getId()) &#123;  </span><br><span class="line">        <span class="keyword">case</span> R.id.et_username:  </span><br><span class="line">            <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_ENTER) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">case</span> R.id.et_password:  </span><br><span class="line">            <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_ENTER) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>返回值为 <strong>true</strong> 代表你将该输入值拦截下来 <strong>自定义处理</strong>，为 <strong>false</strong> 则代表 <strong>不做任何处理</strong>。代码逻辑没有任何问题，回车键也确实已经失效，但当我在密码框输入密码后无意中按下了 <strong>完成</strong> 键时，程序报出空指针异常（三星输入法）。原因是三星键盘中 <strong>完成</strong> 键可以被<strong>onEditorAction()</strong> 方法拦截到，但特别奇怪的是 <strong>该按键为null，并不属于KeyEvent类型</strong>，所以 <strong>event.getKeyCode()</strong> 处会出现异常。<br>解决的方法是：在 <strong>onEditorAction()</strong> 方法第一行先 <strong>判断传入的event对象是否为空</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/assets/blogImg/android_login.png" alt="三星输入法出现的问题"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博主作为一名Android开发新人参与的第一个项目，是开发一个直播软件，我负责信息验证、登录以及设置等功能的实现。坦白讲功能逻辑很简单，如果做Demo大概不过一天工夫。但如果要做得很漂亮，给用户一种非常好的使用体验，一些细节还真的需要仔细琢磨。下面我将分享一下在开发登录功能时遇到的一些值得记录的东西。&lt;/p&gt;
&lt;p&gt;通常来说登录页面包含两个 &lt;strong&gt;EditText&lt;/strong&gt;，分别对应使用者的账号密码（手机端验证码出现比较少，暂不考虑），不妨先来说说一款优秀的手机应用登录页面应该包含哪些人性化的小组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>从博弈论的角度理解2013微软编程之美资格赛题目——竞价</title>
    <link href="http://www.tingxiangshuixie.com/2016/07/21/beauty_of_programming/"/>
    <id>http://www.tingxiangshuixie.com/2016/07/21/beauty_of_programming/</id>
    <published>2016-07-21T20:30:00.000Z</published>
    <updated>2016-12-30T14:08:51.345Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章源自于笔者曾在大学学习运筹学期间的一次演讲，由于老师分配的时间不够等原因，个人当时表现的比较一般，很多同学可能连题目都没搞清楚就结束了。笔者觉得，该题是近几年来微软编程之美中最有趣的一道，无论你是否熟悉数学或编程，都可以看懂这道题目并产生一些自己的想法。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>时间限制</strong>：1000ms</p><p><strong>内存限制</strong>：256MB</p><p><strong>描述</strong></p><p>Alice和Bob都要向同一个商人购买钻石。商人手中有 <strong>N</strong> 颗钻石，他会将它们 <strong>一颗颗</strong> 地卖给他们，Alice和Bob通过竞价的方式来决定钻石的归属。具体的过程如下：商人首先指定其中一个人开始报价，之后两人轮流报价，要求是一定要比对方报的价格 <strong>更高</strong>。任何时候，如果一个人不愿出价或者出不起价钱时，可以宣布 <strong>弃权</strong>，则对手以最后一次报的价格将钻石买下。当然，如果两人都没钱，商人是不会卖钻石的。首次报价至少为 <strong>1</strong>，并且只能报 <strong>整数</strong> 的价钱。</p><p>Alice和Bob特别爱攀比，因此他们都希望 <strong>能比对方买到更多的钻石</strong>。Alice和Bob各自带了 <strong>CA</strong> 和 <strong>CB</strong> 的钱用于竞拍钻石。此外，Alice和商人有很不错的私人关系，因此商人总是会让 <strong>Alice先报价</strong>。现在请问，在Alice和Bob都用 <strong>最优策略</strong> 的情况下，谁能买到更多钻石？ <strong>假设双方都知道对方手中的现金数量，以及商人将要拍卖的钻石数量 N。</strong></p><a id="more"></a><p><strong>输入</strong></p><p>输入文件包含多组测试数据。</p><p>第一行，给出一个整数 <strong>T</strong>，为 <strong>数据组数</strong>。接下来依次给出每组测试数据。</p><p>每组数据为三个用空格隔开的整数 <strong>N</strong>，<strong>CA</strong>，<strong>CB</strong>，表示 <strong>钻石的数量</strong>，以及 <strong>双方带的现金数量</strong>。</p><p><strong>输出</strong></p><p>对于每组测试数据，输出一行 <strong>Case #X: Y</strong>，其中 <strong>X表示测试数据编号</strong>，<strong>Y的取值为{-1, 0, 1}</strong>，<strong>-1</strong> 表示Alice买到的钻石会比Bob <strong>少</strong>，<strong>0</strong> 表示两人能买到 <strong>一样多</strong>，<strong>1</strong> 表示Alice能买到 <strong>更多</strong> 钻石。所有数据按读入顺序从1开始编号。</p><p><strong>数据范围</strong></p><p>1≤T≤1000</p><p>小数据：0≤N≤10; 0&lt;CA, CB≤10</p><p>大数据：0≤N≤105; 0&lt;CA, CB≤106</p><p><strong>样例输入</strong></p><p>2</p><p>4 3 5</p><p>7 4 7</p><p><strong>样例输出</strong></p><p>Case #1: 0</p><p>Case #2: 1</p><h3 id="博弈论，论博弈"><a href="#博弈论，论博弈" class="headerlink" title="博弈论，论博弈"></a>博弈论，论博弈</h3><p>在讨论博弈论之前，我想先谈谈 <strong>博弈</strong>。博弈的目的是 <strong>利益</strong>，利益形成博弈的基础。参与博弈者是为了自身收益的最大化才进行互相竞争。也就是说，参与博弈的各方形成相互竞争、相互对抗的关系， <strong>以争得利益的多少来决定胜负</strong>，而<strong>一定的外部条件</strong>又决定了竞争和对抗的具体形式，这就形成了博弈。</p><p>博弈论的 <strong>4</strong> 个要素：</p><ol><li><strong>2个或2个以上的参与者</strong>。在博弈中存在一个必需的条件即不是一个人在一个毫无干扰的环境中做决策。博弈者的身边充斥着其他具有主观能动性的决策者，他们的选择与其他博弈者的选择相互作用、相互影响。这种互动关系自然会对博弈各方的思维和行动产生重要的影响，有时甚至直接影响博弈结果。</li><li><strong>博弈要有参与各方争夺的资源或收益</strong>。资源指的不仅仅是自然资源，还有人文资源。人们之所以参与博弈是受到利益的吸引，因此预期将来所获得利益的大小直接影响到博弈的吸引力和参与者的关注程度。</li><li><strong>参与者有自己能够选择的策略</strong>。策略，指的是直接、实用地针对某一个具体问题所采取的应对方式。通俗地说，策略就是计策，是博弈参与者所选择的手段方法。博弈论中的策略，是先对局势和整体状况进行分析确定局势特征，找出其中关键因素，为达到最重要的目标进行手段选择。博弈论中的策略是牵一发而动全身的，直接对整个局势造成重大影响。</li><li><strong>参与者拥有一定量的信息</strong>。博弈就是个人或组织在一定的环境条件与既定的规则下，同时或先后，一次或是多次选择策略并实施从而得到某种结果的过程。本题中，Alice和Bob知道对方和钻石商人的一切信息，属于 <strong>完全信息博弈</strong>。</li></ol><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>首先考虑钻石足够多的情况，即 <strong>CA+CB≤N</strong>，易知Alice和Bob谁拥有的钱多谁会获胜，一样多则为平局。</p><p>若 <strong>CA+CB＞N</strong>，我们先来简单分析一下Alice的想法。他如果想要赢得胜利就要尽可能消耗Bob的钱，不能让Bob轻易得到任何一颗钻石。（比如Bob只花费很少的钱买一颗钻石这种事是绝对不可能的，除非Alice没钱了。）但是他也必须通过抬价才能实现上述这个目的。但是Bob也知道Alice拥有的钱，如果Alice漫天要价，Bob就不需要继续跟。那么Alice抬价到多少合适呢？</p><p>我们再分析一下Alice要抬高多少颗钻石的价格。Alice需要把所有的钻石的价格都抬到 <strong>CA/N</strong> 吗？显然不需要，注意Alice和Bob的目的仅仅是 <strong>买得比对方多</strong>，而不是买光所有的钻石。因此，设 <strong>n=[N/2]+1</strong>，我们可以知道Alice或者Bob最少拿到n颗钻石就可以获得胜利，所以Alice要把任意n颗钻石价格抬高到一个特定的数值。 <strong>（注：[x]表示不超过x的最大整数。）</strong></p><p>接下来我们讨论一个命题的正确性：</p><blockquote><p><strong>仅仅在1颗钻石的竞价中，只会出现1次或2次报价，3次及以上的报价是毫无意义的。</strong></p></blockquote><p>由刚才的结论我们知道，Alice在心中有一个 <strong>标准价格</strong>（Bob也知道），所以如果Alice先开价，他就一定会开到这个价格。（开低了Bob就会跟，开高了Bob可以选择放弃。）但是在Alice开低价格的情况下，如果Bob跟的价格恰好是 <strong>标准价格</strong>，Alice则会面临一个很尴尬的情况—— <strong>如果他选择跟，就相当于多花了1元钱而没有对Bob造成损失；如果他不跟，则相当于Bob少花了1元钱就买到了钻石</strong>。</p><p>综上，Alice只会开出 <strong>标准价格</strong>，而Bob也只有 <strong>两种选择——加一元或者是放弃</strong>。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>竞价情况可以分为2种：<strong>N为奇数或偶数</strong>。因为N为奇数不会出现平局，N为偶数可能会出现平局。</p><p>N为奇数时：<strong>n=[N/2]+1</strong>，考虑CA/n，若能整除，显然</p><table><thead><tr><th style="text-align:center">现金比较</th><th style="text-align:center">胜负结果</th></tr></thead><tbody><tr><td style="text-align:center">CB≥(CA/n+1)*n</td><td style="text-align:center">Bob胜</td></tr><tr><td style="text-align:center">CB＜(CA/n+1)*n</td><td style="text-align:center">Alice胜                                       </td></tr></tbody></table><p>若不能整除，则在n颗钻石中会出现一些价格为 <strong>[CA/n]</strong> 的和一些价格为 <strong>[CA/n]+1</strong> 的，易知 <strong>Bob只会在[CA/n]的钻石后跟价</strong>，即</p><table><thead><tr><th style="text-align:center">现金比较</th><th style="text-align:center">胜负结果</th></tr></thead><tbody><tr><td style="text-align:center">CB≥([CA/n]+1)*n</td><td style="text-align:center">Bob胜</td></tr><tr><td style="text-align:center">CB＜([CA/n]+1)*n</td><td style="text-align:center">Alice胜</td></tr></tbody></table><p>举个例子：下为N=5，CA=8，CB=9的情况——<strong>Bob胜利</strong></p><table><thead><tr><th style="text-align:center">人物</th><th style="text-align:center">第1次</th><th style="text-align:center">第2次</th><th style="text-align:center">第3次</th><th style="text-align:center">第4次</th><th style="text-align:center">第5次</th></tr></thead><tbody><tr><td style="text-align:center">Alice</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2    </td></tr><tr><td style="text-align:center">Bob</td><td style="text-align:center">放弃</td><td style="text-align:center">放弃</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3    </td></tr></tbody></table><p>N为偶数时，<strong>n=[N/2]+1</strong>，由奇数情况易推知</p><table><thead><tr><th style="text-align:center">现金比较</th><th style="text-align:center">胜负结果</th></tr></thead><tbody><tr><td style="text-align:center">CB≥([CA/(n-1)]+1)*n</td><td style="text-align:center">Bob胜</td></tr><tr><td style="text-align:center">CB≥([CA/n]+1)*(n-1)</td><td style="text-align:center">平局</td></tr><tr><td style="text-align:center">CB＜([CA/n]+1)*(n-1)</td><td style="text-align:center">Alice胜</td></tr></tbody></table><p>第一个式子的含义是：<strong>Bob连平局的机会（即Alice只想买前一半数量的钻石）都没有给，在Alice最大程度的阻挠下依然赢得比赛所满足的条件</strong>。</p><p>第二个式子的含义是：<strong>Alice想赢得比赛，所以要给前n颗钻石抬价，但是Bob仍然有能力买下一半的钻石阻止Alice获胜</strong>。</p><p>至此，题目得到解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章源自于笔者曾在大学学习运筹学期间的一次演讲，由于老师分配的时间不够等原因，个人当时表现的比较一般，很多同学可能连题目都没搞清楚就结束了。笔者觉得，该题是近几年来微软编程之美中最有趣的一道，无论你是否熟悉数学或编程，都可以看懂这道题目并产生一些自己的想法。&lt;/p&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;时间限制&lt;/strong&gt;：1000ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存限制&lt;/strong&gt;：256MB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Alice和Bob都要向同一个商人购买钻石。商人手中有 &lt;strong&gt;N&lt;/strong&gt; 颗钻石，他会将它们 &lt;strong&gt;一颗颗&lt;/strong&gt; 地卖给他们，Alice和Bob通过竞价的方式来决定钻石的归属。具体的过程如下：商人首先指定其中一个人开始报价，之后两人轮流报价，要求是一定要比对方报的价格 &lt;strong&gt;更高&lt;/strong&gt;。任何时候，如果一个人不愿出价或者出不起价钱时，可以宣布 &lt;strong&gt;弃权&lt;/strong&gt;，则对手以最后一次报的价格将钻石买下。当然，如果两人都没钱，商人是不会卖钻石的。首次报价至少为 &lt;strong&gt;1&lt;/strong&gt;，并且只能报 &lt;strong&gt;整数&lt;/strong&gt; 的价钱。&lt;/p&gt;
&lt;p&gt;Alice和Bob特别爱攀比，因此他们都希望 &lt;strong&gt;能比对方买到更多的钻石&lt;/strong&gt;。Alice和Bob各自带了 &lt;strong&gt;CA&lt;/strong&gt; 和 &lt;strong&gt;CB&lt;/strong&gt; 的钱用于竞拍钻石。此外，Alice和商人有很不错的私人关系，因此商人总是会让 &lt;strong&gt;Alice先报价&lt;/strong&gt;。现在请问，在Alice和Bob都用 &lt;strong&gt;最优策略&lt;/strong&gt; 的情况下，谁能买到更多钻石？ &lt;strong&gt;假设双方都知道对方手中的现金数量，以及商人将要拍卖的钻石数量 N。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
  <entry>
    <title>Git的基本配置</title>
    <link href="http://www.tingxiangshuixie.com/2016/07/19/git_configuration/"/>
    <id>http://www.tingxiangshuixie.com/2016/07/19/git_configuration/</id>
    <published>2016-07-19T20:30:00.000Z</published>
    <updated>2017-09-14T13:59:44.737Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或大或小的项目。而由Git衍生出的项目托管平台，包括Github和Gitlab两种。开发者可以将开源项目免费托管在Github的云中，但私有库则需要付费。所以，基于节约开支、方便管理和安全性高等好处，诸多互联网公司选择在自己的服务器上搭建Gitlab来托管代码。</p><p>在初次接触到Git时，除了感慨版本控制系统的功能强大之外，遇到了很多配置的问题，现总结如下。</p><a id="more"></a><h3 id="SSH-Key配置"><a href="#SSH-Key配置" class="headerlink" title="SSH Key配置"></a>SSH Key配置</h3><p>在Git Bash中输入 <strong>ssh-keygen -t rsa -C “<a href="mailto:xxx@yourmail.com" target="_blank" rel="noopener">xxx@yourmail.com</a>“</strong> 后输入配置公钥密钥保存位置及密码，完成后登录至Github/GitLab网站并将.ssh文件下的id_rsa.pub文件中的密钥复制到Github/GitLab的SSH Keys选项添加认证。在本地Git Bash登录Github/GitLab账户，利用 <strong>ssh -T git@yourserver</strong> 确认登录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一些常用的Git命令：</span><br><span class="line">    git clone git<span class="meta">@yourproject</span>.git <span class="comment">//克隆原始仓库的项目到本地</span></span><br><span class="line">    git branch xxx <span class="comment">//在本地新建xxx分支</span></span><br><span class="line">    git push origin xxx <span class="comment">//将更新文件或新建分支推送到远程仓库xxx分支</span></span><br><span class="line">    git checkout xxx <span class="comment">//切换到xxx分支上</span></span><br><span class="line">    git branch -d xxx <span class="comment">//删除本地的xxx分支</span></span><br><span class="line">    git merge master <span class="comment">//将当前分支与master分支合并</span></span><br><span class="line">    git add -A <span class="comment">//将新增加的文件及被修改的文件添加到暂存区</span></span><br><span class="line">    git commit -m <span class="string">"xxx"</span> <span class="comment">//确认添加到暂存区的文件并生成记录</span></span><br><span class="line">    git log <span class="comment">//查看所有的commit记录（注：退出记录按“Q”按键）</span></span><br><span class="line">    git log --graph --pretty=oneline --abbrev-commit <span class="comment">//树状展示commit记录</span></span><br><span class="line">    git pull origin master <span class="comment">//从远程仓库master分支获取更新</span></span><br></pre></td></tr></table></figure><p>一个小技巧：如果你常用Git Bash的话，一定要在 <strong>.gitconfig</strong> 文件中添加     <strong>[alias]</strong> 标签并自定义一些缩写方式，如“co = checkout”、“br = branch”、“ci = commit -m”等。</p><h3 id="Git统一换行符"><a href="#Git统一换行符" class="headerlink" title="Git统一换行符"></a>Git统一换行符</h3><p>Git支持的换行符有三种，分别为 <strong>CRLF(\r\n)</strong>、<strong>LF(\n)</strong>、<strong>CR(\r)</strong>，一般来说LF格式使用最为广泛，在此博主也推荐在开发过程中尽量统一格式为 <strong>LF</strong>（Intellij<br> IDEA/Android studio中File-Line Separators设置）。当在Windows系统使用Git在保存文件修改操作时换行符报错，保证代码中只包含 <strong>一种</strong> 换行符并在 <strong>.gitconfig</strong> 文件中加入如下代码即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    autocrlf = false //不进行格式转换</span><br><span class="line">    safecrlf = true //拒绝提交包含混合换行符的文件</span><br></pre></td></tr></table></figure><h3 id="取消新项目进行pull-push操作时输入密码"><a href="#取消新项目进行pull-push操作时输入密码" class="headerlink" title="取消新项目进行pull/push操作时输入密码"></a>取消新项目进行pull/push操作时输入密码</h3><p>在添加了SSH Key后，登陆已经不需要输入账号密码。但是在新项目pull和push操作时还是会输入账号密码，使用以下方法可以避免重复输入操作。</p><ol><li>Git Bash进入Git的根路径，在我的电脑上是——C:\Users\xxx</li><li>在该路径下输入 <strong>touch .git-credentials</strong> 创建文件</li><li>继续输入“vim .git-credentials”编辑文件，如果是Github项目直接输入<strong><a href="https://yourusername:yourpassword@github.com" target="_blank" rel="noopener">https://yourusername:yourpassword@github.com</a></strong>。但如果是Gitlab项目，笔者建议直接退出文件编辑而选择在Git<br>Bash中输入一遍账号密码（可自动添加到.git-credentials文件中而避免路径写错等问题）。</li><li>在Git Bash中输入 <strong>git config –global credential.helper store</strong>，成功后在 <strong>.gitconfig</strong> 文件中可以看到 <strong>helper = store</strong> 字符。</li><li>执行一次pull或push操作，输入一次账号密码后打开.git-credentials文件，是否发现多了一条 <strong>http(https)://yourusername:yourpassword@yourserver</strong> 记录？再次执行pull或push操作，已经不需要输入账号密码了。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>熟练掌握Git的使用几乎是每个程序员的必经之路，Git的使用方式并不复杂，但笔者一路走来也遇到了不少坑。值得庆幸的是，很多优秀的集成开发环境已经将Git融入，使用起来更加简单且样式美观。不过我觉得还是应该掌握Git Bash的基础使用方法后再去使用其他Git UI，并非出于对命令窗口的执着，而是——<strong>源码</strong> 咱们都理解了，再用起来 <strong>封装</strong> 岂不是更熟练吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或大或小的项目。而由Git衍生出的项目托管平台，包括Github和Gitlab两种。开发者可以将开源项目免费托管在Github的云中，但私有库则需要付费。所以，基于节约开支、方便管理和安全性高等好处，诸多互联网公司选择在自己的服务器上搭建Gitlab来托管代码。&lt;/p&gt;
&lt;p&gt;在初次接触到Git时，除了感慨版本控制系统的功能强大之外，遇到了很多配置的问题，现总结如下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="往者可鉴" scheme="http://www.tingxiangshuixie.com/tags/%E5%BE%80%E8%80%85%E5%8F%AF%E9%89%B4/"/>
    
  </entry>
  
</feed>
